### 一、模板类别

​	数据结构：带懒惰标记的 `zkw` 版位集

​	练习题目：

1. [2166. 设计位集](https://leetcode.cn/problems/design-bitset/)
2. [3161. 物块放置查询](https://leetcode.cn/problems/block-placement-queries/)
3. [#2037. 「SHOI2015」脑洞治疗仪](https://loj.ac/p/2037)
4. [P1503 鬼子进村](https://www.luogu.com.cn/problem/P1503)
5. [P1840 Color the Axis](https://www.luogu.com.cn/problem/P1840)
6. [P2434 [SDOI2005] 区间](https://www.luogu.com.cn/problem/P2434)
7. [P2572 [SCOI2010] 序列操作](https://www.luogu.com.cn/problem/P2572)
8. [P2894 [USACO08FEB] Hotel G](https://www.luogu.com.cn/problem/P2894)
9. [P3740 [HAOI2014] 贴海报](https://www.luogu.com.cn/problem/P3740)
10. [P4344 [SHOI2015] 脑洞治疗仪](https://www.luogu.com.cn/problem/P4344)
11. [P4979 矿洞：坍塌](https://www.luogu.com.cn/problem/P4979)
12. [P5057 [CQOI2006] 简单题](https://www.luogu.com.cn/problem/P5057)

### 二、模板功能

#### 1.建立位集

1. 数据类型

   类型设定 `size_type = uint32_t` ，表示树中结点在内存池上的下标的类型。

   模板参数 `bool MaintainLongest` ，表示是否维护最长连续零/一。

   构造参数 `size_type length` ，表示位集的覆盖范围为 `[0, length)`。默认值为 `0` 。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   在标准库中有 `std::bitset` 可以作为位集，但是 `std::bitset` 有长度无法改变、无法进行区间修改、区间查询的缺点。本数据结构实现了区间赋值、区间翻转、区间查询 `1` 的数量的功能。

   本模板与 `LazyBitset` 的区别是，本模板基于非递归线段树，常数非常小。

#### 2.重置(resize)

1. 数据类型

   输入参数 `size_type length` ，表示位集的大小为 `length`。

2. 时间复杂度

    $O(n)$ 。

####  3.全部置为1(set)

1. 数据类型

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   调用本函数会将位集的每一位置为 `1` 。

#### 4.将某一位置为1(set)

1. 数据类型

   输入参数 `size_type i` ，表示将下标 `i` 位置置为 `1` 。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 5.将某一区间置为1(set)

1. 数据类型

   输入参数 `size_type left` ，表示要修改的区间的起始下标。

   输入参数 `size_type right` ，表示要修改的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

####  6.全部置为0(reset)

1. 数据类型

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   调用本函数会将位集的每一位置为 `0` 。

#### 7.将某一位置为0(reset)

1. 数据类型

   输入参数 `size_type i` ，表示将下标 `i` 位置置为 `0` 。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 8.将某一区间置为0(reset)

1. 数据类型

   输入参数 `size_type left` ，表示要修改的区间的起始下标。

   输入参数 `size_type right` ，表示要修改的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

####  9.全部翻转(flip)

1. 数据类型

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   调用本函数会将位集的每一位翻转。

#### 10.将某一位置翻转(flip)

1. 数据类型

   输入参数 `size_type i` ，表示将下标 `i` 翻转。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 11.将某一区间翻转(flip)

1. 数据类型

   输入参数 `size_type left` ，表示要修改的区间的起始下标。

   输入参数 `size_type right` ，表示要修改的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 12.查询1的总数(count)

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

#### 13.查询区间中1的总数(count)

1. 数据类型

   输入参数 `size_type left` ，表示要查询的区间的起始下标。

   输入参数 `size_type right` ，表示要查询的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 14.查询是否有1(any)

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

#### 15.查询区间中是否有1(any)

1. 数据类型

   输入参数 `size_type left` ，表示要查询的区间的起始下标。

   输入参数 `size_type right` ，表示要查询的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 16.查询是否全为1(all)

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

#### 17.查询区间中是否全为1(all)

1. 数据类型

   输入参数 `size_type left` ，表示要查询的区间的起始下标。

   输入参数 `size_type right` ，表示要查询的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 18.查询区间内最长连续1

1. 数据类型

   输入参数 `size_type left` ，表示要查询的区间的起始下标。

   输入参数 `size_type right` ，表示要查询的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$  。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 19.查询区间内最长连续0

1. 数据类型

   输入参数 `size_type left` ，表示要查询的区间的起始下标。

   输入参数 `size_type right` ，表示要查询的区间的结尾下标。（闭区间）

2. 时间复杂度

   $O(\log n)$  。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 20.查询第一个1的位置(first_one)

1. 数据类型

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中全部都是 `0` ，没有 `1` 时，返回 `-1` 。

#### 21.查询最后一个1的位置(last_one)

1. 数据类型

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中全部都是 `0` ，没有 `1` 时，返回 `-1` 。

#### 22.查询第一个0的位置(first_zero)

1. 数据类型

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中全部都是 `1` ，没有 `0` 时，返回 `-1` 。

#### 23.查询最后一个0的位置(last_zero)

1. 数据类型

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中全部都是 `1` ，没有 `0` 时，返回 `-1` 。

#### 24.查询前一个1的位置(prev_one)

1. 数据类型

   输入参数 `size_type i` ，表示当前下标。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中下标 `i` 之前全部都是 `0` ，没有 `1` 时，返回 `-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 25.查询后一个1的位置(next_one)

1. 数据类型

   输入参数 `size_type i` ，表示当前下标。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中下标 `i` 之后全部都是 `0` ，没有 `1` 时，返回 `-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 26.查询前一个0的位置(prev_zero)

1. 数据类型

   输入参数 `size_type i` ，表示当前下标。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中下标 `i` 之前全部都是 `1` ，没有 `0` 时，返回 `-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 27.查询后一个0的位置(next_zero)

1. 数据类型

   输入参数 `size_type i` ，表示当前下标。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   当位集中下标 `i` 之后全部都是 `1` ，没有 `0` 时，返回 `-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 28.查询某下标(at)

1. 数据类型

   输入参数 `size_type i` ，表示要查询的下标。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 29.查询第k个1(kth)

1. 数据类型

   输入参数 `size_type k` ，表示要查询的排名。

   输入参数 `size_type pos` ，表示从 `pos` 位置开始数。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0, n)`）

#### 30.树上二分查询右边界(max_right)

1. 数据类型

   模板参数 `typename Getter` ，表示结点属性访问器。
   
   输入参数 `size_type left` ，表示左边界。

   输入参数 `Judger &&judge` ，表示需要满足的判断条件。

   返回类型 `size_type` ，表示在满足条件情况下的最大右边界。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   假设本函数返回 `r` ，则表示，对于 `i∈[left, r]`  ，均有 `judge(query(left, i))` 为真。而当 `i>r` 时，有 `judge(query(left, i))` 为假。显然，`r` 的最大值为 `m_sz-1` 。

   如果从 `left` 开始，即使长度为一的区间也不能满足判断条件，那么返回 `left-1`  。所以 `r` 的最小值为 `left-1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 31.树上二分查询左边界(min_left)

1. 数据类型

   模板参数 `typename Getter` ，表示结点属性访问器。
   
   输入参数 `size_type right` ，表示右边界。

   输入参数 `Judger &&judge` ，表示需要满足的判断条件。

   返回类型 `size_type` ，表示在满足条件情况下的最小左边界。

2. 时间复杂度

   $O(\log n)$ 。

3. 备注

   假设本函数返回 `l` ，则表示，对于 `i∈[l, right]`  ，均有 `judge(query(i, right))` 为真。而当 `i<l` 时，有 `judge(query(i, right))` 为假。显然，`l` 的最小值为 `0` 。

   如果从 `right` 开始往左走，即使长度为一的区间也不能满足判断条件，那么返回 `right+1`  。所以 `l` 的最大值为 `right+1` 。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

#### 32.枚举所有的零(enumerate_zero)

1. 数据类型

   输入参数 `Callback &&call` ，表示对每个为零的位置调用的回调函数。

2. 时间复杂度

   $O(n)$ ，此处 `n` 指零的个数。

#### 33.枚举所有的一(enumerate_one)

1. 数据类型

   输入参数 `Callback &&call` ，表示对每个为一的位置调用的回调函数。

2. 时间复杂度

   $O(n)$ ，此处 `n` 指一的个数。
   
#### 34.枚举所有的一的区间(enumerate_range)

1. 数据类型

   输入参数 `Callback &&call` ，表示对每个为一的连续区间调用的回调函数。

2. 时间复杂度

   $O(n)$ ，此处 `n` 指一的段数。
   

#### 三、模板示例

```c++
#include "DS/ZkwBitset.h"
#include "IO/FastIO.h"

void test() {
    OY::ZkwTreeBitset<> B(10000);
    // 将区间置为 1
    B.set(1000, 3000);
    cout << "B[1000~2000]=" << B.count(1000, 2000) << endl;
    // 将区间置为 0
    B.reset(500, 1400);
    cout << "B[1000~2000]=" << B.count(1000, 2000) << endl;
    // 将整个位集翻转
    B.flip();
    cout << "B[1000~2000]=" << B.count(1000, 2000) << endl;

    for (int i = 1395; i < 1405; i++)
        cout << "index " << i << ":" << B.at(i) << endl;

    // 全部置为 0
    B.reset();

    B.set(16);
    B.set(980);
    B.set(357);
    B.set(2);
    for (int i = B.first_one(); i >= 0; i = B.next_one(i))
        cout << i << ' ';
    cout << endl;
    for (int i = B.last_one(); i >= 0; i = B.prev_one(i))
        cout << i << ' ';
    cout << endl;
}

int main() {
    test();
}
```

```
#输出如下
B[1000~2000]=1001
B[1000~2000]=600
B[1000~2000]=401
index 1395:1
index 1396:1
index 1397:1
index 1398:1
index 1399:1
index 1400:1
index 1401:0
index 1402:0
index 1403:0
index 1404:0
2 16 357 980 
980 357 16 2 

```

