### 一、模板类别

​	数据结构：可持久化线段树

​	练习题目：

1. [To the moon](https://acm.hdu.edu.cn/showproblem.php?pid=4348)
2. [P3834 【模板】可持久化线段树 2](https://www.luogu.com.cn/problem/P3834)
3. [P3835 【模板】可持久化平衡树](https://www.luogu.com.cn/problem/P3835)
4. [P3919 【模板】可持久化线段树 1（可持久化数组）](https://www.luogu.com.cn/problem/P3919)

### 二、模板功能

​		本数据结构的功能与实现与线段树几乎一致，在此之外仅仅添加了可持久化的功能。所以与线段树相同部分的内容不再介绍。

​		在可持久化数据结构中，不同版本的数据结构可能会共享很多数据，因此，当某一个版本进行写操作时，必须将涉及到的数据拷贝出来一份再进行修改，以避免对其他版本造成影响。然而，在进行单纯的读操作时，并不需要将涉及到的数据拷贝出来再进行读。所以，本数据结构新增了模板参数 `bool Lock` ，表示是否含有锁，如果没有锁，那么无论读还是写都会引发拷贝操作；如果有锁，那么可以通过静态函数 `lock` 和 `unlock` 进行状态切换，当 `lock` 之后，树上操作不会进行数据拷贝； `unlock` 之后，树上操作会引起数据拷贝。默认状态为已上锁，请在写操作前解锁，并在写操作完成后上锁。

​		在支持区间修改的树里，即使是写操作也可能引起懒惰标记下传，所以一般模板参数 `Lock` 设为 `false` 。

#### 1.拷贝线段树(copy)

1. 数据类型

2. 时间复杂度

    $O(1)$ 。

3. 备注

   在可持久化数据结构中，一棵树的拷贝就是其根节点的拷贝。至于子孙结点，并不需要即时全部拷贝，等到之后进行访问的时候，才会逐个进行拷贝。

   **注意：**本函数名“拷贝”并不等价于上文中的数据拷贝。本函数只涉及根结点的拷贝；数据拷贝指的是从根到叶结点的链的拷贝。

#### 2.版本间的差分树上求第k个元素(reduce_kth)

1. 数据类型

2. 时间复杂度

    $O(\log n)$ 。

3. 备注

   本方法为静态方法。

   如果一个版本的树是在另一个版本的基础上经历若干次修改得来，那么两棵树的差就体现了这些修改。如果树为加和树，而要在差分中寻找第 `k` 个元素，可以调用本方法。
   

### 三、模板示例

```c++
#include "DS/PersistentSegTree.h"
#include "IO/FastIO.h"

void test_no_lock() {
    // 这是一个长度为5的数组
    int A[5] = {100, 200, 300, 400, 500};
    // 写一个默认的支持区间加的求和树
    OY::PerSeg::Tree<OY::PerSeg::LazyNode<int, int, uint32_t>, OY::PerSeg::Ignore, false, false, uint32_t> T(A, A + 5);
    cout << T << endl
         << endl;

    auto T2 = T.copy();
    T2.add(1, 1000);

    auto T3 = T2.copy();
    T3.add(2, -1000);

    auto T4 = T.copy();
    T4.add(0, 3, 10000);

    T.add(0, 3, 100000);
    cout << "T :" << T << endl;
    cout << "T2:" << T2 << endl;
    cout << "T3:" << T3 << endl;
    cout << "T4:" << T4 << endl;
}

void test_with_lock() {
    // 这是一个长度为5的数组
    int A[5] = {100, 200, 300, 400, 500};
    // 写一个默认的求和树
    OY::PerSeg::Tree<OY::PerSeg::BaseNode<int>, OY::PerSeg::Ignore, true, true, uint32_t> T(A, A + 5);
    cout << T << endl
         << endl;

    auto T2 = T.copy();
    // 静态函数解锁
    decltype(T2)::unlock();
    T2.add(1, 1000);
    decltype(T2)::lock();

    auto T3 = T2.copy();
    // 可以通过普通函数方式调用解锁
    T3.unlock();
    T3.add(2, -1000);
    T3.lock();

    auto T4 = T.copy();
    // 同类型共享锁
    T2.unlock();
    T.add(0, 10000);
    T2.lock();

    cout << "T :" << T << endl;
    cout << "T2:" << T2 << endl;
    cout << "T3:" << T3 << endl;
    cout << "T4:" << T4 << endl;
}

int main() {
    test_no_lock();
    test_with_lock();
}
```

```
#输出如下
[100, 200, 300, 400, 500]

T :[100100, 100200, 100300, 100400, 500]
T2:[100, 1200, 300, 400, 500]
T3:[100, 1200, -700, 400, 500]
T4:[10100, 10200, 10300, 10400, 500]
[100, 200, 300, 400, 500]

T :[10100, 200, 300, 400, 500]
T2:[100, 1200, 300, 400, 500]
T3:[100, 1200, -700, 400, 500]
T4:[100, 200, 300, 400, 500]

```

