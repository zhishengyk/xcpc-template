### 一、模板类别

​	数据结构：二维线段树（动态开点线段树套动态开点线段树）

​	练习题目：

1. [P3380 【模板】树套树](https://www.luogu.com.cn/problem/P3380)
2. [P3834 【模板】可持久化线段树 2](https://www.luogu.com.cn/problem/P3834)

### 二、模板功能

#### 1.建立二维线段树

1. 数据类型

   类型设定 `size_type = uint32_t` ，表示树中结点在内存池上的下标。

   模板参数 `typename CommutativeMonoid` ，表示交换幺半群类型。

   模板参数 `typename SizeType` ，表示表示区域大小时，所采用的数的类型。在区间长度为 `1e9` 级别时，采用 `uint32_t` 为佳；区间长度更长时，采用 `uint64_t` 。当然采用有符号数也无大碍。

   构造参数 `SizeType row` ，表示线段树的行范围为 `[0, row)`。默认值为 `0` 。

   构造参数 `SizeType column` ，表示线段树的列范围为 `[0, column)`。默认值为 `0` 。

2. 时间复杂度

    $O(1)$ 。

3. 备注

   二维线段树处理的问题为单点修改，单点/区域和的查询。

   二维线段树可以实现二维树状数组的绝大部分功能，而且可以实现更强的功能，比如区域最值查询、区域按位与、区域按位或。但是不能实现二维树状数组加强版的区域修改功能。这是因为二维树状数组本身也不能实现区域修改功能，加强版的区域修改功能只不过是在加法运算符、差分性质下做到的特例。

   不同于二维树状数组，二维线段树对任意区域的查询，都是通过自下而上的累积而来，而非通过差分求得。

   目前二维线段树的大量细节都放到了模板参数 `CommutativeMonoid` 中，只需要设计好 `CommutativeMonoid` 即可让线段树工作。

   对于二维线段树来说，交换幺半群须满足以下要求：

   1. 声明 `value_type` 为值类型；
   
   2. 定义静态函数 `op` ，接受两个 `value_type` 参数，返回它们的聚合值；
   
   3. 定义静态函数 `identity` ，无输入参数，返回幺元。
   
   4. 定义静态函数 `get` ，输入行起点、行终点、列起点、列终点，返回初始情况下此子矩形的聚合值。

   一般的，我们称 `op` 函数执行的是聚合操作，二维线段树要求区间操作函数的运算符满足**结合律**和**交换律**。

   **注意：**

   本模板大部分与 `ZkwTree2D` 模板重合，且速度更慢。那本模板存在的意义是什么？ 

   `SegTree2D` 可以处理维护较大范围的区间（甚至可以达到 $10^{18}$ ），因为 `SegTree2D` 可以动态开点，即树不一定是满二叉树，初始时可以是空的，在需要的时候再去初始化从根到叶子的一条链；而 `ZkwTree2D` 只能处理相对较小范围的区域（面积 $10^6$ 以内），因为 `ZkwTree2D` 必须初始化整颗二叉树。


####  2.重置(resize)

1. 数据类型

   输入参数 `SizeType row` ，表示二维线段树的行范围为 `[0, row)`。

   输入参数 `SizeType column` ，表示二维线段树的列范围为 `[0, column)`。

2. 时间复杂度

   $O(m\cdot n)$ 。

3. 备注

   使用映射函数进行初始化，可以将区间初状态直接赋到线段树里。
   
   参数中的 `mapping` 参数，入参为行下标、列下标，返回值须为一个 `value_type` 对象。在调用时，会按照行下标从 `0` 到 `row-1` 、列下标从 `0` 到 `column-1` 依次调用。

#### 3.单点增值(add)

1. 数据类型

   输入参数 `SizeType i` ，表示单点增值的行下标。

   输入参数 `SizeType j` ，表示单点增值的列下标。

   输入参数 `value_type inc​` ，表示增量大小。

2. 时间复杂度

   $O(\log m\cdot\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 4.单点赋值(modify)

1. 数据类型

   输入参数 `SizeType i` ，表示单点赋值的行下标。

   输入参数 `SizeType j` ，表示单点赋值的列下标。

   输入参数 `value_type val​` ，表示赋的值。

2. 时间复杂度

   $O(\log m\cdot\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 5.单点查询(query)

1. 数据类型

   输入参数 `SizeType row` ，表示单点查询的行下标。

   输入参数 `SizeType column` ，表示单点查询的列下标。

2. 时间复杂度

   $O(\log m+\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 6.区域查询(query)

1. 数据类型

   输入参数 `SizeType row1` ，表示区域查询的起始行下标。

   输入参数 `SizeType row2` ，表示区域查询的结束行下标。（闭区间）

   输入参数 `SizeType column1​` ，表示区域查询的起始列下标。

   输入参数 `SizeType column2` ，表示区域查询的结束列下标。（闭区间）

2. 时间复杂度

   $O(\log m\cdot\log n)$ 。
   
3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 7.查询全部(query_all)

1. 数据类型

2. 时间复杂度

   $O(1)$ 。
   

#### 8.从某些行中查询第k个元素(kth)

1. 数据类型

   输入参数 `SizeType row1` ，表示区域查询的起始行下标。

   输入参数 `SizeType row2` ，表示区域查询的结束行下标。（闭区间）

   输入参数 `value_type k​` ，表示查询的名次。

2. 时间复杂度

   $O(\log m\cdot\log n)$ 。

3. 备注

   本函数可以这样表述：找到最小的列号 `c` ，使得 `query(row1, row2, 0, c) >= k + 1` 成立。

   本函数常用于维护带修区间第 `k` 大元素。

### 三、模板示例

```c++
#include "DS/SegTree2D.h"
#include "IO/FastIO.h"

int main() {
    // 二维线段树与一维线段树的用法基本类似，所以只展示一下特殊方法
    int matrix[4][5] = {
        {3, 0, 1, 4, 2},
        {5, 6, 3, 2, 1},
        {1, 2, 0, 1, 5},
        {4, 1, 0, 1, 7},
    };
    // 除了行数、列数，还需要传递一个寻址函数
    OY::VectorSumSeg2D<int64_t, 0, uint32_t> T(4, 5);
    for (int i = 0; i < 4; i++)
        for (int j = 0; j < 5; j++) T.add(i, j, matrix[i][j]);
    cout << T << endl;
    // 输出[0,2]行，[1,4]列的和
    cout << "sum(matrix[0~2][1~4])=" << T.query(0, 2, 1, 4) << endl;
}
```

```
#输出如下
[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7]]
sum(matrix[0~2][1~4])=27

```

