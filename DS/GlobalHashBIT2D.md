### 一、模板类别

​	数据结构：哈希二维树状数组

​	练习题目：

1. [#133. 二维树状数组 1：单点修改，区间查询](https://loj.ac/p/133)
2. [#134. 二维树状数组 2：区间修改，单点查询](https://loj.ac/p/134)
3. [#135. 二维树状数组 3：区间修改，区间查询](https://loj.ac/p/135)
4. [P3810 【模板】三维偏序（陌上花开）](https://www.luogu.com.cn/problem/P3810)
5. [P4054 [JSOI2009] 计数问题](https://www.luogu.com.cn/problem/P4054)
6. [P4514 上帝造题的七分钟](https://www.luogu.com.cn/problem/P4514)



### 二、模板功能

#### 1.建立二维树状数组

1. 数据类型

   模板参数 `typename KeyType` ，表示二维树状数组的下标类型。

   模板参数 `typename MappedType` ，表示二维树状数组的值类型。

   模板参数 `bool RangeUpdate`​ ，表示是否要支持区域修改。

   模板参数 `bool MakeRecord` ，表示是否对哈希表里插入过的结点进行记录。

   模板参数 `size_type BUFFER`​ ，表示哈希表的结点数为 `BUFFER` 。

   构造参数 `size_type row` ，表示二维树状数组的行范围为 `[0, row)`。

   构造参数 `size_type column` ，表示二维树状数组的列范围为 `[0, column)`。

2. 时间复杂度

    $O(n)$ ，此处 `n` 指哈希表的大小 `BUFFER` 。

3. 备注

   二维树状数组处理的问题为单点修改，单点/区域和的查询。当 `RangeUpdate` 参数设置为 `true` 时，可以同时兼备区域增值修改的功能，但是时空效率都会下降。
   
   二维树状数组通过加和函数求解前缀和，再通过前缀和做差求解任意区域和。

   二维树状数组通过一些差分运算，实现了区域修改。
   
   本模板完全为普通版的二维树状数组把占用数组替换为哈希表后的平替，牺牲了效率，换来了表达空间的增大。


#### 2.单点增值(add)

1. 数据类型

   输入参数 `KeyType i​` ，表示单点增值的行下标。
   
   输入参数 `KeyType j​` ，表示单点增值的列下标。

   输入参数 `const MappedType &inc​` ，表示增量大小。

2. 时间复杂度

   均摊 $O(\log m \cdot \log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）


#### 3.区域增值(add)

1. 数据类型

   输入参数 `KeyType row1` ，表示区域增值的起始行下标。

   输入参数 `KeyType row2` ，表示区域增值的结束行下标。（闭区间）

   输入参数 `KeyType column1​` ，表示区域增值的起始列下标。

   输入参数 `KeyType column2` ，表示区域增值的结束列下标。（闭区间）

   输入参数 `const MappedType &inc` ，表示增量大小。

2. 时间复杂度

   均摊 $O(\log m\cdot\log n)$ 。

3. 备注

   本方法仅当 `RangeUpdate` 为 `true` 时合法。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）
   
#### 4.前缀和查询(presum)

1. 数据类型
   
   输入参数 `KeyType i`，表示前缀和查询的结尾行下标。(闭区间)

   输入参数 `KeyType j`，表示前缀和查询的结尾列下标。(闭区间)

2. 时间复杂度

   均摊 $O(\log m\cdot\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）


#### 5.单点查询(query)

1. 数据类型
   
   输入参数 `KeyType i` ，表示单点查询的行下标。

   输入参数 `KeyType j` ，表示单点查询的列下标。

2. 时间复杂度

   均摊 $O(\log m\cdot\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）


#### 6.区间查询(query)

1. 数据类型
   
   输入参数 `KeyType row1` ，表示区域查询的起始行下标。

   输入参数 `KeyType row2` ，表示区域查询的结束行下标。（闭区间）

   输入参数 `KeyType column1​` ，表示区域查询的起始列下标。

   输入参数 `KeyType column2` ，表示区域查询的结束列下标。（闭区间）

2. 时间复杂度

   均摊 $O(\log m\cdot\log n)$ 。
   
3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）


#### 7.查询全部和(query_all)

1. 数据类型

2. 时间复杂度

   均摊 $O(\log m\cdot\log n)$ 。


#### 8.清空(clear)

1. 数据类型

2. 时间复杂度

    $O(n)$ ，此处 `n` 指此前树状数组操作涉及的结点数。

3. 备注

   本方法仅当 `MakeRecord` 为 `true` 时使用。


### 三、模板示例

```c++
#include "DS/GlobalHashBIT2D.h"
#include "IO/FastIO.h"

// 本模板用法完全等同于普通二维树状数组
// 注意，对象必须声明在全局
OY::GBIT2D::Tree<uint32_t, uint64_t, true, true, 1009> Gbit(100000, 100000);
int main() {
    Gbit.add(0, 100000, 0, 100000, 1);
    Gbit.add(100000, 500000, 100000, 500000, 2);
    cout << Gbit.query(50000, 450000, 50000, 450000) << endl;
    Gbit.clear();
    cout << Gbit.query(50000, 450000, 50000, 450000) << endl;
}
```

```
#输出如下
2500000000
0

```

