### 一、模板类别

​	数据结构：可持久化并查集

​	练习题目：

1. [P3402 可持久化并查集](https://www.luogu.com.cn/problem/P3402)
2. [U208135 可持久化并查集 加强版](https://www.luogu.com.cn/problem/U208135)

### 二、模板功能

​		本数据结构的实现与并查集不同。但是功能则大同小异，在此之外仅仅添加了可持久化的功能。所以与并查集相同部分的内容不再介绍。

​		需要注意的是，其实是和并查集相同的功能，时间复杂度上往往会乘个 $\log n$ 。

     本数据结构支持动态开点，也就是可以快速初始化一个大小为 `1e18` 的并查集。

#### 1.拷贝并查集(copy)

1. 数据类型

2. 时间复杂度

    $O(1)$ 。

3. 备注

   在可持久化数据结构中，一棵树的拷贝就是其根节点的拷贝。至于子孙结点，并不需要即时全部拷贝，等到之后进行访问的时候，才会逐个进行拷贝。

#### 2.查询分组首领(find)

1. 数据类型

   参数 `SizeType i` ，表示要寻找元素 `i` 所在分组的首领。

   返回类型 `info` ，表示找到的分组首领，以及分组的大小。

2. 时间复杂度

   均摊 $O(\alpha (n)\cdot \log n)$  。

3. 备注

   在可持久化并查集里，进行一次查询的代价较大。所以除了返回分组首领，顺便返回分组的大小，以避免重复查询。

### 三、模板示例

```c++
#include "DS/PersistentDSU.h"
#include "IO/FastIO.h"

int main() {
    OY::VectorPerDSUTable<uint32_t, true> u(10);
    cout << u << '\n';

    auto u2 = u.copy();
    u2.unite_by_size(1, 2);
    u2.unite_by_size(1, 3);
    u2.unite_by_size(2, 4);
    cout << u2 << '\n';

    auto u3 = u2.copy();
    u3.unite_by_size(6, 7);
    u3.unite_by_size(8, 9);
    u3.unite_by_size(7, 8);
    cout << u3 << '\n';

    auto u4 = u.copy();
    u4.unite_by_size(1, 7);

    cout << u << '\n';
    cout << u2 << '\n';
    cout << u3 << '\n';
    cout << u4 << '\n';
}
```

```
#输出如下
[(0,1), (1,1), (2,1), (3,1), (4,1), (5,1), (6,1), (7,1), (8,1), (9,1)]
[(0,1), (2,4), (2,4), (2,4), (2,4), (5,1), (6,1), (7,1), (8,1), (9,1)]
[(0,1), (2,4), (2,4), (2,4), (2,4), (5,1), (9,4), (9,4), (9,4), (9,4)]
[(0,1), (1,1), (2,1), (3,1), (4,1), (5,1), (6,1), (7,1), (8,1), (9,1)]
[(0,1), (2,4), (2,4), (2,4), (2,4), (5,1), (6,1), (7,1), (8,1), (9,1)]
[(0,1), (2,4), (2,4), (2,4), (2,4), (5,1), (9,4), (9,4), (9,4), (9,4)]
[(0,1), (7,2), (2,1), (3,1), (4,1), (5,1), (6,1), (7,2), (8,1), (9,1)]

```

