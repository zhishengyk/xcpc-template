### 一、模板类别

​	数据结构：`K` 阶树状数组

​	练习题目：

1. [#P5428. K阶求和数列](https://new.bzoj.org:88/p/P5428)
2. [P4062 [Code+#1] Yazid 的新生舞会](https://www.luogu.com.cn/problem/P4062)
3. [P4458 [BJOI2018] 链上二次求和](https://www.luogu.com.cn/problem/P4458)
4. [牛牛的等差数列](https://ac.nowcoder.com/acm/problem/204829)
5. [智乃酱的平方数列](https://ac.nowcoder.com/acm/problem/226172)



### 二、模板功能

#### 1.建立K阶树状数组

1. 数据类型

   类型设定 `size_type = size_t` ，表示 `k` 阶树状数组中下标编号的变量类型。

   模板参数 `typename Tp` ，表示元素类型。要求为模数类。

   模板参数 `size_type MAXK`​ ，表示前缀和的最大阶数。

   构造参数 `size_type length` ，表示树状数组的覆盖范围为 `[0, length)`。

   构造参数 `InitMapping mapping` ，表示在初始化时，从下标到值的映射函数。

2. 时间复杂度

    $O(k\cdot n)$ 。

3. 备注

    `K`阶树状数组是普通树状数组的进阶版，可以同时维护原数组及其 `1~K` 阶的前缀和；通过差分运算实现区间加常数、二次函数、三次函数乃至 `K` 次函数。

   本模板要求元素类型 `Tp` 为任意自取模数类，且模数为质数。即便不能保证模数为质数，至少保证在 `1` 到 `MAXK - 1` 的范围内有逆元。
   
   模板参数 `MAXK` 是前缀和表的最大阶数，它决定了操作的复杂程度。例如， `MAXK` 为 `1` ，则本模板仅为普通树状数组； `MAXK` 为 `2` ，则本模板等价于区间加树状数组，在原数组两次点修实现一阶前缀和的区间修改，在二阶前缀和表两次点查询实现一阶前缀和的区间查询； `MAXK` 越大，支持的操作更强。

   本构造方法要求元素支持 `+=` 运算符。

   **注意：**

   对于一个特定模数、特定阶数的 `K` 阶树状数组，必须要先调用 `prepare` 静态方法进行预处理之后才可以正常使用，且本方法在全局只需要调用一次。特别的，如果自取模数类为动态模数，在设置新模数之后需要重新 `prepare` 。调用 `prepare` 的时间复杂度为 `K` 的三次方。
   
   **注意：**

   构造参数中的 `mapping` 参数，入参为下标，返回值须为一个 `Tp` 对象。若不传递此参数，表示不进行初始化，比如要建立一颗空的求和树状数组。


#### 2.建立K阶树状数组

1. 数据类型

   构造参数 `Iterator first` ，表示区间维护的区间头。

   构造参数 `Iterator last` ，表示区间维护的区间尾。（开区间）

   其它同上。

2. 时间复杂度

   同上。

3. 备注

   同上。

   使用迭代器进行初始化，可以将区间初状态直接赋到 `K` 阶树状数组里。



#### 3.重置(resize)

1. 数据类型

   输入参数 `size_type length` ，表示 `K` 阶树状数组要处理的区间大小。

   输入参数 `InitMapping mapping` ，表示初始化时，从下标到值的映射函数。

2. 时间复杂度

    $O(n)$ 。

3. 备注

   使用映射函数进行初始化，可以将区间初状态直接赋到 `K` 阶树状数组里。
   
    `mapping` 要求传入一个下标，返回一个 `Tp` 类型的值。在调用时，会按照下标从 `0` 到 `length-1` 依次调用。


#### 4.重置(reset)

1. 数据类型

   输入参数 `Iterator first` ，表示区间维护的区间头。

   输入参数 `Iterator last` ，表示区间维护的区间尾。（开区间）

2. 时间复杂度

   同上。

3. 备注

   同上。

   使用迭代器进行重置，可以将区间初状态直接赋到 `K` 阶树状数组里。


#### 5.单点增值(add)

1. 数据类型

   输入参数 `size_type i​` ，表示单点增值的下标。

   输入参数 `const Tp &inc​` ，表示增量大小。

2. 时间复杂度

   $O(k\cdot\log n)$ 。

3. 备注

   本方法的直接操作对象为原数组，同时会对 `1~K` 阶的前缀和产生影响。

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）
   

#### 6.区间增值(add)

1. 数据类型

   模板参数 `size_type K` ，表示要进行操作的前缀和表的阶数。

   输入参数 `size_type left` ，表示区间增值的开头下标。

   输入参数 `size_type right​` ，表示区间增值的结尾下标。(闭区间)

   输入参数 `const std::array<Tp, L> &inc` ，表示要进行增加的多项式的每项的系数。

2. 时间复杂度

   $O(k^2\cdot\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`，且 `left <= right + 1` ）

   本方法要求 `1<=K<=MAXK` ，且 `L<=K` 。显然，本方法并不能对原数组进行区间修改。区间修改时增加的多项式的次数小于前缀和的层数，例如对于二阶前缀和只能进行区间线性增加，这恰好对应着一阶前缀和的区间常量增加，这恰好是我们比较熟悉的区间加树状数组的原理。

#### 7.区间增值动态方法(add_dynamic)

1. 数据类型

   输入参数 `size_type k` ，表示要进行操作的前缀和表的阶数。
   
   其余同上。

2. 时间复杂度

   同上。

3. 备注

   本方法为区间增值的动态版本。由于有的时候，区间增值针对的前缀和的阶数是运行期参数，所以提供本动态方法。

   当阶数为静态数字时，推荐使用静态方法，效率更高。

#### 8.单点查询(query)

1. 数据类型

   模板参数 `size_type K` ，表示要进行查询的前缀和表的阶数。

   输入参数 `size_type i` ，表示单点查询的下标。

2. 时间复杂度

   $O(k\cdot\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`）

   本方法要求 `1<=K<=MAXK` 。显然，本方法并不能对原数组进行单点查询。如果想查询原数组的单点值，可以通过一阶前缀和表差分运算得到。

#### 9.单点查询动态方法(query_dynamic)

1. 数据类型

   输入参数 `size_type k` ，表示要进行操作的前缀和表的阶数。
   
   其余同上。

2. 时间复杂度

   同上。

3. 备注

   本方法为单点查询的动态版本。由于有的时候，单点查询针对的前缀和的阶数是运行期参数，所以提供本动态方法。

   当阶数为静态数字时，推荐使用静态方法，效率更高。


#### 10.区间查询(query)

1. 数据类型

   模板参数 `size_type K` ，表示要进行查询的前缀和表的阶数。

   输入参数 `size_type left​` ，表示区间查询的开头下标。

   输入参数 `size_type right​`，表示区间查询的结尾下标。(闭区间)

2. 时间复杂度

   $O(k^2\cdot\log n)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，n)`，且 `left <= right + 1` ）

   本方法要求 `0<=K<MAXK` 。本方法的结果均由更高一阶的前缀和表的单点查询值差分得到。

#### 11.区间查询动态方法(query_dynamic)

1. 数据类型

   输入参数 `size_type k` ，表示要进行操作的前缀和表的阶数。
   
   其余同上。

2. 时间复杂度

   同上。

3. 备注

   本方法为区间查询的动态版本。由于有的时候，区间查询针对的前缀和的阶数是运行期参数，所以提供本动态方法。

   当阶数为静态数字时，推荐使用静态方法，效率更高。


### 三、模板示例

```c++
#include "DS/KBIT.h"
#include "IO/FastIO.h"
#include "MATH/StaticModInt32.h"

void test() {
    using mint = OY::mint1000000007;
    using KBIT = OY::KBIT::Tree<mint, 5>;
    KBIT::prepare();

    int a[9] = {4, 9, 2, 3, 5, 7, 8, 1, 6};
    KBIT S(a, a + 9);

    // 把原数组和各阶前缀和输出
    auto print = [&]() {
        cout << "orignal array:\t";
        for (int idx = 0; idx < 9; idx++) cout << S.query<1>(idx) - S.query<1>(idx - 1) << " \n"[idx == 8];
        for (int idx = 0; idx < 9; idx++) cout << S.query<1>(idx) << " \n"[idx == 8];
        for (int idx = 0; idx < 9; idx++) cout << S.query<2>(idx) << " \n"[idx == 8];
        for (int idx = 0; idx < 9; idx++) cout << S.query<3>(idx) << " \n"[idx == 8];
        for (int idx = 0; idx < 9; idx++) cout << S.query<4>(idx) << " \n"[idx == 8];
        for (int idx = 0; idx < 9; idx++) cout << S.query<5>(idx) << " \n"[idx == 8];
        cout << endl;
    };
    print();

    // 给 5 阶前缀和表下标 0~3 添加 (100000,400000,900000,1600000)
    // 也就是多项式 (i+1)^2 * 100000
    S.add<5>(0, 3, std::array<mint, 3>{100000, 200000, 100000});
    print();

    // 给 2 阶前缀和表下标 1~4 添加 (1,2,3,4)
    // 也就是多项式 i^1
    S.add<2>(1, 4, std::array<mint, 2>{0, 1});
    print();
}

int main() {
    test();
}
```

```
#输出如下
orignal array:	4 9 2 3 5 7 8 1 6
4 13 15 18 23 30 38 39 45
4 17 32 50 73 103 141 180 225
4 21 53 103 176 279 420 600 825
4 25 78 181 357 636 1056 1656 2481
4 29 107 288 645 1281 2337 3993 6474

orignal array:	100004 999900016 999900009 100003 997500012 8900007 988100015 7100001 998400013
100004 13 999900022 18 997500030 6400030 994500045 1600039 45
100004 100017 32 50 997500080 3900103 998400148 180 225
100004 200021 200053 200103 997700183 1600279 420 600 825
100004 300025 500078 700181 998400364 636 1056 1656 2481
100004 400029 900107 1600288 645 1281 2337 3993 6474

orignal array:	100004 999900017 999900009 100003 997500012 8900002 988100019 7100001 998400013
100004 14 999900023 19 997500031 6400026 994500045 1600039 45
100004 100018 34 53 997500084 3900103 998400148 180 225
100004 200022 200056 200109 997700193 1600289 430 610 835
100004 300026 500082 700191 998400384 666 1096 1706 2541
100004 400030 900112 1600303 680 1346 2442 4148 6689


```

