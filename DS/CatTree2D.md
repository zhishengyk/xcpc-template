### 一、模板类别

​	数据结构：二维猫树。

​	练习题目：

1. [Check Corners](http://acm.hdu.edu.cn/showproblem.php?pid=2888)

### 二、模板功能

#### 1.建立二维猫树

1. 数据类型

   类型设定 `size_type = uint32_t` ，表示树中结点在内存池上的下标。

   模板参数 `typename CommutativeSemiGroup` ，表示交换半群类型。

   构造参数 `size_type row` ，表示猫树的行范围为 `[0, row)`。默认值为 `0` 。

   构造参数 `size_type column` ，表示猫树的列范围为 `[0, column)`。默认值为 `0` 。

   构造参数 `InitMapping init_mapping` ，表示在初始化时，从下标到值的映射函数。

2. 时间复杂度

    $O(m\cdot n\cdot \log m\cdot\log n)$ ，其中 `m` 和 `n` 分别表示行数和列数。

3. 备注

   二维猫树处理的问题为区域最值查询，可以是区域最大值、区域最小值，也可以是区域按位或、区域按位与、区域最大公约数。这些是和二维 `ST` 表统一的功能。除此之外，二维猫树还可以重载加法、乘法、按位异或，这些是二维 `ST` 表做不到的。

   二维猫树模板的大量细节都放到了模板参数 `CommutativeSemiGroup` 中，只需要设计好 `CommutativeSemiGroup` 即可让猫树工作。

   对于二维猫树来说，交换半群须满足以下要求：

   1. 声明 `value_type` 为值类型；
   2. 定义静态函数 `op` ，接受两个 `value_type` 参数，返回它们的聚合值；

   一般的，我们称 `op` 函数执行的是聚合操作，二维猫树要求区间操作函数的运算符满足**结合律**和**交换律**。本模板不要求有幺元。

   **注意：**

   构造参数中的 `mapping` 参数，入参为行下标、列下标，返回值为一个 `value_type` 对象。

####  2.重置(resize)

1. 数据类型

   输入参数 `size_type row` ，表示二维猫树的行范围为 `[0, row)`。

   输入参数 `size_type column` ，表示二维猫树的列范围为 `[0, column)`。

   构造参数 `InitMapping init_mapping` ，表示在初始化时，从行列下标到值的映射函数。

2. 时间复杂度

   $O(m\cdot n\cdot \log m\cdot\log n)$ ，其中 `m` 和 `n` 分别表示行数和列数。

3. 备注

   使用映射函数进行初始化，可以将区间初状态直接赋到线段树里。

   参数中的 `mapping` 参数，入参为行下标、列下标，返回值须为一个 `value_type` 对象。在调用时，会按照行下标从 `0` 到 `row-1` 、列下标从 `0` 到 `column-1` 依次调用。

#### 3.单点查询(query)

1. 数据类型

   输入参数 `size_type row` ，表示单点查询的行下标。

   输入参数 `size_type column` ，表示单点查询的列下标。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 4.区域查询(query)

1. 数据类型

   输入参数 `size_type row1` ，表示区域查询的起始行下标。

   输入参数 `size_type row2` ，表示区域查询的结束行下标。（闭区间）

   输入参数 `size_type column1​` ，表示区域查询的起始列下标。

   输入参数 `size_type column2` ，表示区域查询的结束列下标。（闭区间）

2. 时间复杂度

    $O(1)$ 。

3. 备注

   本函数没有进行参数检查，所以请自己确保下标合法。（位于`[0，m), [0, n)`）

#### 5.查询全部(query_all)

1. 数据类型

2. 时间复杂度

   $O(1)$ 。


### 三、模板示例

```c++
#include "DS/CatTree2D.h"
#include "IO/FastIO.h"

int main() {
    // 二维猫树与一维猫树的用法基本类似，所以只展示一下特殊方法
    int matrix[4][5] = {
        {3, 0, 1, 4, 2},
        {5, 6, 3, 2, 1},
        {1, 2, 0, 1, 5},
        {4, 1, 0, 1, 7},
    };
    // 除了行数、列数，还需要传递一个寻址函数
    auto T = OY::CatMaxTable2D<int>(4, 5, [&](int i, int j) { return matrix[i][j]; });
    cout << T << endl;
    // 输出[0,2]行，[1,4]列的最大值
    cout << "max(matrix[0~2][1~4])=" << T.query(0, 2, 1, 4) << endl;
}
```

```
#输出如下
[[3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7]]
max(matrix[0~2][1~4])=6

```
