### 一、模板类别

​	数据结构：二维差分。

​	练习题目：

1. [T271585 【模板】二维前缀和](https://www.luogu.com.cn/problem/T271585)
2. [T275009 【模板】二维差分](https://www.luogu.com.cn/problem/T275009)
3. [T332686 二维差分](https://www.luogu.com.cn/problem/T332686)
4. [U223961 差分矩阵](https://www.luogu.com.cn/problem/U223961)


### 二、模板功能

#### 1.初始化

1. 数据类型

   类型设定 `size_type = uint32_t` ，表示矩阵大小的类型。

   模板参数 `typename CommutativeGroup` ，表示交换群类型。

   模板参数 `bool AutoSwitch` ，表示是否自动切换状态。

   构造参数 `size_type row`  ，表示维护的行范围为 `[0, row-1]` 。

   构造参数 `size_type column`  ，表示维护的列范围为 `[0, column-1]` 。

   构造参数 `InitMapping mapping` ，表示在初始化时，从下标到值的映射函数。

2. 时间复杂度

    $O(m\cdot n)$ 。

3. 备注

   本模板通过模板参数 `typename CommutativeGroup` 确定交换群。交换群须满足以下要求：

1. 声明 `value_type` 为值类型；

2. 定义静态函数 `op` ，接受两个 `value_type` 参数，返回它们的聚合值；

3. 定义静态函数 `identity` ，无输入参数，返回幺元。

4. 定义静态函数 `inverse` ，输入参数一个 `value_type` ，返回其逆元。

    本模板要求区间操作函数的运算符满足**结合律**和**交换律**。常见的交换群为加法群和异或群。
   
   本数据结构，处于三种状态之一，且可以随时切换。

   当处于差分态 `TABLE_DIFFERENCE` 时，便于进行“将某个子矩形增加一定的值”操作；

   当处于值态时 `TABLE_VALUE` ，便于进行“将某个点增加一定的值”或者“查询某点的值”操作；

   当处于前缀和态 `TABLE_PRESUM` 时，便于进行“查询某个子矩形的和”操作。

   状态切换需要 $O(m\cdot n)$ 的时间，所以使用时尽量避免频繁切换状态。
   
   如果担心忘记切换状态，可以将 `AutoSwitch` 设为 `true` ，则在调用函数时会自动切换到最合适的状态。

   **注意：**

   构造参数中的 `mapping` 参数，入参为行下标、列下标，返回值须为一个 `value_type` 对象。如果不传递此参数，表示不进行初始化，此时的初状态为 `TABLE_ANY` 态，可以认为为任意状态。如果进行了有意义的初始化，则初状态为 `TABLE_VALUE` 态。

#### 2.重置(resize)

1. 数据类型

   输入参数 `size_type row`  ，表示维护的行范围为 `[0, row-1]` 。

   输入参数 `size_type column`  ，表示维护的列范围为 `[0, column-1]` 。

   输入参数 `InitMapping mapping` ，表示在初始化时，从下标到值的映射函数。

2. 时间复杂度

    $O(m\cdot n)$ 。

3. 备注

   使用映射函数进行初始化，可以将区间初状态直接赋到二维差分表里。

   构造参数中的 `mapping` 参数，入参为行下标、列下标，返回值须为一个 `value_type` 对象。在调用时，会按照行下标从 `0` 到 `row-1` 、列下标从 `0` 到 `column-1` 依次调用。
   
   本函数没有进行参数检查，所以请自己确保下标合法。（行号、列号位于 `[0，m)`, `[0, n)`）

#### 3.单点增值(add)

1. 数据类型

   输入参数 `size_type i` ，表示要增值的点所在行。

   输入参数 `size_type j` ，表示要增值的点所在列。

   输入参数 `value_type inc`​ ，表示要增加的值。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本操作须在值态下进行。

   本函数没有进行参数检查，所以请自己确保下标合法。（行号、列号位于 `[0，m)`, `[0, n)`）

#### 4.单点赋值(modify)

1. 数据类型

   输入参数 `size_type i` ，表示要赋值的点所在行。

   输入参数 `size_type j` ，表示要赋值的点所在列。

   输入参数 `value_type inc`​ ，表示要赋的值。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本操作须在值态下进行。

   本函数没有进行参数检查，所以请自己确保下标合法。（行号、列号位于 `[0，m)`, `[0, n)`）

#### 5.区域增值(add)

1. 数据类型

   输入参数 `size_type row1` ，表示要增值的子矩形的开始行。

   输入参数 `size_type row2` ，表示要增值的子矩形的结束行。

   输入参数 `size_type column1` ，表示要增值的子矩形的开始列。

   输入参数 `size_type column2` ，表示要增值的子矩形的结束列。

   输入参数 `value_type inc`​ ，表示要增加的值。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本操作须在差分态下进行。

   本函数没有进行参数检查，所以请自己确保下标合法。（行号、列号位于 `[0，m)`, `[0, n)`）

#### 6.单点查询(query)

1. 数据类型

   输入参数 `size_type i` ，表示要增值的点所在行。

   输入参数 `size_type j` ，表示要增值的点所在列。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本操作须在值态下进行。

   本函数没有进行参数检查，所以请自己确保下标合法。（行号、列号位于 `[0，m)`, `[0, n)`）

#### 7.区域查询(query)

1. 数据类型

   输入参数 `size_type row1` ，表示要查询的子矩形的开始行。

   输入参数 `size_type row2` ，表示要查询的子矩形的结束行。

   输入参数 `size_type column1` ，表示要查询的子矩形的开始列。

   输入参数 `size_type column2` ，表示要查询的子矩形的结束列。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本操作须在前缀和态下进行。

   本函数没有进行参数检查，所以请自己确保下标合法。（行号、列号位于 `[0，m)`, `[0, n)`）

#### 8.查询全部(query_all)

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本操作须在前缀和态下进行。


#### 9.切换状态到差分态(switch_to_difference)

1. 数据类型

2. 时间复杂度

   $O(m\cdot n)$ 。

3. 备注

   切换到差分态，以便进行区域修改。

#### 10.切换状态到值态(switch_to_value)

1. 数据类型

2. 时间复杂度

   $O(m\cdot n)$ 。

3. 备注

   切换到值态，以便进行单点修改和单点查询。

   **注意：**如果要进行整表输出，也请切换到值态。

#### 11.切换状态到前缀和态(switch_to_presum)

1. 数据类型

2. 时间复杂度

   $O(m\cdot n)$ 。

3. 备注

   切换到前缀和态，以便进行区域查询。


### 三、模板示例

```c++
#include "DS/AdjDiff2D.h"
#include "IO/FastIO.h"

int main() {
    // 当 AutoSwitch 为 true 时，其实可以不用手动转换状态
    OY::AdjSumTable2D<int, true> ad(4, 5);

    cout << ad << endl;

    // ad.switch_to_value();
    ad.add(1, 2, 10);
    ad.add(2, 4, 100);
    cout << ad << endl;

    // ad.switch_to_difference();
    ad.add(1, 3, 0, 2, 1000);

    // ad.switch_to_value();
    cout << ad << endl;
}
```

```
#输出如下
[[0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]
[[0, 0, 0, 0, 0], [0, 0, 10, 0, 0], [0, 0, 0, 0, 100], [0, 0, 0, 0, 0]]
[[0, 0, 0, 0, 0], [1000, 1000, 1010, 0, 0], [1000, 1000, 1000, 0, 100], [1000, 1000, 1000, 0, 0]]

```

