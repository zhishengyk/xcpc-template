### 一、模板类别

​	数学：高精度整数。

### 二、模板功能

#### 1.构造

1. 数据类型

   模板参数 `uint32_t _B` ，表示进制，默认为 `10` 。

   模板参数 `uint32_t _W` ，表示压位宽度，默认为 `6` 。

   模板参数 `uint32_t _MAXN` ，表示最大位数，默认为 `1 << 20` 。

   模板参数 `uint64_t _P` ，表示进行蒙哥马利模乘时的模数，默认为 `9223372006790004737` 。

   模板参数 `uint64_t _R` ，表示 `_P` 对应的原根，默认为 `3` 。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本模板用于大数运算。

   进制 `_B` 须为大于 `1` 的整数。在 `10` 进制及以下，每一位默认对应数字字符；在 `11` 进制到 `36` 进制，增加的数字用小写字母对应；在 `37` 进制到 `62` 进制，增加的数字用大写字母对应。当进制更大时，暂无对应的字符规则，此时与字符串相关的操作会受到影响，但是其他操作仍可以进行。

   在无参情况下，大数默认初始化为零。

   当 `m_length` 属性为零时，大数为零，此时不存在 `m_data` 指向的数据，且 `m_nagetive` 只能为 `false` 。其他情况下， `m_data` 指向数据区，且 `m_nagetive` 指示正负号。注意， `m_length` 并不是大数的位长度，而是压位之后的位长度。

   下文中，用 `bint` 代指本大数类。

   **注意：**

   1. 压位宽度 `_W` 须满足，当两个大数已相乘，且暂未进位时，乘积上的每一位数字须小于 `_P` 。例如，假如要进行两个长度 `1000` 的十进制大数的乘法，压位宽度为 `5` ，那么因数的每个压位后的数字最大为 `99999` （约为 `1e5` ），最多可能有 `200` 对 `99999^2` 聚集到乘积的某一位，则此位的最大值约为 `2e12` ，没有超过默认 `_P` ，所以压位宽度 `_W = 5` 是可行的。如果压位宽度为 `8` ，那么因数的每个压位后的数字最大为 `99999999` （约为 `1e8` ），最多可能有 `125` 对 `99999999^2` 聚集到乘积的某一位，则此位的最大值约为 `1.25e18` ，没有超过默认 `_P` ，所以压位宽度 `_W = 8` 也是可行的。如果压位宽度为 `9` ，那么因数的每个压位后的数字最大为 `999999999` （约为 `1e9`），最多可能有 `111` 对 `999999999^2` 聚集到乘积的某一位，则此位的最大值约为 `1.1e20` ，超过了默认 `_P` ，所以压位宽度 `_W = 9` 是不行的。

      同时， `_W` 影响程序运行速度， `_W` 越大，速度越快。

      在十进制下，一般可以将 `_W` 设为 `6` ，对于千万位级别以下的运算都兼容；而且速度也够快了。在位数更短的情况下可以酌情增大 `_W` ，提高程序速度。

   2. 最大位数 `_MAXN` 用来设置乘法/除法计算时的缓存空间。`_MAXN` 须不小于乘法运算所涉及的大数位数。比如要计算一个 `1000` 位的十进制数，和一个 `1200` 位的十进制数的乘积，那么 `_MAXN` 至少为 `1200` 。

      当发生除法运算时，应将 `_MAXN` 设为更大。比如当 `1000` 位的十进制数，除以 `20` 位的十进制数，会将这两个大数同时按位左移约 `960` 位，变成 `1960` 位的大数除以 `980` 位的大数，此时 `_MAXN` 如果仍为 `1000` 左右就会产生错误。所以为了使除法运算正常进行， `_MAXN` 至少应当设为参与运算的的大数的位数的二倍。

      当然，在空间限制不紧张的情况下， `_MAXN` 适当开大一点也没问题。

   3. 进行快速数论变换时，需要的变换长度必须是 `_P-1` 的因数，且为 `2` 的幂。由于 `9223372006790004737 == 2147483641 * 2 ^ 32 + 1` ，所以在常规数据规模下，不需要考虑这一条。


#### 2.构造

1. 数据类型

   构造参数 `_Tp __number` ，表示从 `_Tp` 转化为大数类。`_Tp` 可以为 `int` ， `long long` 等有符号数，也可以为 `uint32_t` ， `uint64_t` 等无符号数，也可以为 `__int128_t` 等类型。

   其余同上。

2. 时间复杂度

   $O(\frac{\log_b n}{_W})$ ，此处 `b` 为进制大小， `n` 为数字的绝对值大小， `W` 为压位宽度。

   或者说 $O(\frac n W)$ ，此处 `n` 为 `b` 进制下数字的长度， `W` 为压位宽度。

3. 备注

   **注意：** 如果输入的参数为负数，转化过程中会转化为相反数。所以如果 `_Tp`  为 `int` ，当 `__number==-2147483648` 时，转化为相反数会出错。如果 `_Tp`  为 `long long` ，当 `__number==9223372036854775808` 时，转化为相反数会出错。

#### 3.构造

1. 数据类型

   构造参数 `const char *__number` ，表示从常量字符串转化为大数类。

   其余同上。

2. 时间复杂度

   同上。

3. 备注

   **注意：** 字符串中，允许有前导零，允许首位为 `+` 或者 `-` 表示正负号，除此之外只能为数字字符，不能有空格、回车等字符。

#### 4.构造

1. 数据类型

   构造参数 `const std::string &__number` ，表示从字符串转化为大数类。

   其余同上。

2. 时间复杂度

   同上。

3. 备注

   **注意：** 字符串中，允许有前导零，允许首位为 `+` 或者 `-` 表示正负号，除此之外只能为数字字符，不能有空格、回车等字符。

#### 5.构造

1. 数据类型

   构造参数 `bint &&__other` ，表示从右值移动构造大数。

   其余同上。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   当移动构造完成后， `__other` 值为零。

#### 6.构造

1. 数据类型

   构造参数 `const bint &__other` ，表示从另一个大数拷贝构造大数。

   其余同上。

2. 时间复杂度

   $O(\frac{\log_b n}{_W})$ ，此处 `b` 为进制大小， `n` 为数字的绝对值大小， `W` 为压位宽度。

   或者说 $O(\frac n W)$ ，此处 `n` 为 `b` 进制下数字的长度， `W` 为压位宽度。

#### 7.析构

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

#### 8.生成随机数

1. 数据类型

   输入参数 `uint32_t __length` ，表示要生成的随机数的位数。

   返回类型 `bint` ，表示位长度为 `__length` 的大数。

2. 时间复杂度

   $O(\frac{\log_b n}{_W})$ ，此处 `b` 为进制大小， `n` 为数字的绝对值大小， `W` 为压位宽度。

   或者说 $O(\frac n W)$ ，此处 `n` 为 `b` 进制下数字的长度， `W` 为压位宽度。

3. 备注

   本方法只返回正数，所以要求 `__length` 为正。

   本方法保证生成的 `__length` 位长度的随机数首位非零。

#### 9.比较绝对值大小

1. 数据类型

   输入参数 `const bint &__a` ，表示参与比较的第一个大数。

   输入参数 `const bint &__b` ，表示参与比较的第二个大数。

   返回类型 `int` ，可以为 `-1` ， `0` ， `1` ，分别表示前者绝对值小于、等于、大于后者绝对值。

2. 时间复杂度

   $O(1\sim\frac{\log_b n}{_W})$ ，此处 `b` 为进制大小， `n` 为数字的绝对值大小， `W` 为压位宽度。

3. 备注

   如果两个大数的位数不同，则可以直接确定二者绝对值的大小。否则需要从高位到低位诸位比较。

#### 10.带余除法

1. 数据类型

   模板参数 `bool _Mod` ，表示是否计算余数。

   输入参数 `const bint &__a` ，表示被除数。

   输入参数 `const bint &__b` ，表示除数。

   当 `_Mod == true` 时，返回类型为一个结构体 ，包含商和余数；当 `_Mod == false` 时，返回类型为 `bint` ，表示商。

2. 时间复杂度

   $O(\frac{\log_b n}{_W}\cdot \log\frac{\log_b n}{_W})$ ，此处 `b` 为进制大小， `n` 为数字的绝对值大小， `W` 为压位宽度。

   或者说 $O(\frac n W\cdot\log \frac n W)$ ，此处 `n` 为 `b` 进制下数字的长度， `W` 为压位宽度。

3. 备注

   本除法与 `int` 除法相同，当不能整除时，向商向 `0` 靠拢取整。

   **注意：** 除数不能为零。

#### 11.带余除法

1. 数据类型

   输入参数 `const bint &__a` ，表示被除数。

   输入参数 `long long __b` ，表示除数。

   返回类型为一个结构体 ，包含商和余数。

2. 时间复杂度

   $O(\frac{\log_b n}{_W})$ ，此处 `b` 为进制大小， `n` 为数字的绝对值大小， `W` 为压位宽度。

   或者说 $O(\frac n W)$ ，此处 `n` 为 `b` 进制下数字的长度， `W` 为压位宽度。

3. 备注

   本除法与 `int` 除法相同，当不能整除时，向商向 `0` 靠拢取整。

   **注意：** 除数不能为零。

#### 12.收缩

1. 数据类型

2. 时间复杂度

   $O(n)$ ，`n` 表示多余的零。

3. 备注

   本成员方法用于将多余的前导零删除；当绝对值为零时，将符号置为正。

#### 13.变为相反数

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本成员方法将大数本身置为自己的相反数。

   当大数绝对值为零时，无法设置为负。

#### 14.设置是否为负

1. 数据类型

   输入参数 `bool __negative` ，表示是否设置为负数。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本成员方法根据参数，将大数设置为正或负。

   当大数绝对值为零时，无法设置为负。

#### 15.移动赋值

1. 数据类型

   输入参数 `bint &&__other` ，表示从右值移动赋值大数。

2. 时间复杂度

   $O(1)$ 。

3. 备注

   本成员方法用于使用等于号，将 `__other` 表示的大数移动到本大数里。

   移动赋值完成后， `__other` 值为本大数原值。实际相当于进行了 `swap` 操作。

#### 16.拷贝赋值

1. 数据类型

   输入参数 `const bint &__other` ，表示从左值拷贝赋值大数。

2. 时间复杂度

   $O(\frac{\log_b n}{_W})$ ，此处 `b` 为进制大小， `n` 为数字的绝对值大小， `W` 为压位宽度。

   或者说 $O(\frac n W)$ ，此处 `n` 为 `b` 进制下数字的长度， `W` 为压位宽度。

3. 备注

   本成员方法用于使用等于号，将 `__other` 表示的大数的值赋到本大数里。

   拷贝赋值完成后， `__other` 值不会发生改变。

#### 17.取位长度

1. 数据类型

2. 时间复杂度

   $O(\log W)$ ，此处 `W` 为压位宽度。

   因为 `W` 往往很小，所以可以视为 $O(1)$ 。

3. 备注

   本成员方法用于取出大数在当前进制表示下，所占用的位长度。

   比如：`12345678` ，在十进制下的位长度为 `8` 。

   **注意：** 本属性不同于 `m_length` 的值。`m_length` 表示，在将 `_W` 位压缩到一位里，所得的位数。

#### 18.幂

1. 数据类型

   输入参数 `uint64_t __n` ，表示指数大小。

   返回类型 `bint` ，表示幂的值。

2. 时间复杂度

   $O(\frac{\log_b n}{_W}\cdot \log\frac{\log_b n}{_W}\cdot\log m)$ ，此处 `b` 为进制大小， `n` 为数字的绝对值大小， `W` 为压位宽度， `m` 为指数的大小。

   或者说 $O(\frac n W\cdot\log \frac n W\cdot \log m)$ ，此处 `n` 为 `b` 进制下数字的长度， `W` 为压位宽度， `m` 为指数的大小。

3. 备注

   本成员方法使用快速幂的方法进行次方求值。

#### 19.开方

1. 数据类型

   输入参数 `uint32_t __n` ，表示开方次数。

   返回类型 `bint` ，表示得到的开方结果。

2. 时间复杂度

   $O(\frac{\log_b n}{_W}\cdot \log^2\frac{\log_b n}{_W})$ ，此处 `b` 为进制大小， `n` 为数字的绝对值大小， `W` 为压位宽度。

   或者说 $O(\frac n W\cdot\log^2 \frac n W)$ ，此处 `n` 为 `b` 进制下数字的长度， `W` 为压位宽度。

3. 备注

   本成员方法使用 `std::log` 函数进行预估初值，然后进行牛顿迭代求解。

#### 20.各种运算符

1. 数据类型

2. 时间复杂度

   对于 `++` （前置）， `--` （前置）运算符，均摊复杂度为 $O(1)$ ，最差时间复杂度为 $O(n)$ ，此处 `n` 表示大数的位长度。

   对于 `++` （后置）， `--` （后置）， `+=` ， `-=` ， `+` ， `-` ， `*=(long long)` ， `/=(long long)` ， `%=(long long)` ， `<<=` ， `>>=` ， `+`（正号） ， `-` （负号），`==` ， `!=` ， `<` ， `>` ， `<=` ， `>=` ， `*(long long)` ， `/(long long)` ， `%(long long)` ， `<<` ， `>>` ，等运算符，时间复杂度为 $O(n)$  ，此处 `n` 表示大数的位长度。

   对于 `*=(bint)` ， `/=(bint)` ， `%=(bint)` ， `*(bint)` ，`/(bint)` ， `%(bint)` 等运算符，时间复杂度为 $O(n\cdot \log n)$ ，此处 `n` 表示大数的位长度。

3. 备注

   运算符的效果非常显然，不一一阐述。

   **注意：** 此处 `<<` ， `>>` ， `<<=` ， `>>=` 符号，同样是按位移动，但是并不是按二进制位移动，而是按当前进制进行按位移动。

#### 21.强制类型转换为布尔

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

#### 22.强制类型转换为数字类型

1. 数据类型

   模板参数 `typename _Tp` ，表示要转换为的类型。

   返回类型 `_Tp` ，表示转换结果。

2. 时间复杂度

   $O(\frac{\log_b n}{_W})$ ，此处 `b` 为进制大小， `n` 为数字的绝对值大小， `W` 为压位宽度。

   或者说 $O(\frac n W)$ ，此处 `n` 为 `b` 进制下数字的长度， `W` 为压位宽度。

3. 备注

   在对超过 `int` 上限的大数强制转换为 `int` 时会出错， `long long` 同理。

#### 23.转换为字符串

1. 数据类型

   返回类型 `std::string` ，表示转换结果。

2. 时间复杂度

   $O(\frac{\log_b n}{_W})$ ，此处 `b` 为进制大小， `n` 为数字的绝对值大小， `W` 为压位宽度。

   或者说 $O(\frac n W)$ ，此处 `n` 为 `b` 进制下数字的长度， `W` 为压位宽度。

#### 24.流式输入输出

1. 数据类型

2. 时间复杂度

   $O(\frac{\log_b n}{_W})$ ，此处 `b` 为进制大小， `n` 为数字的绝对值大小， `W` 为压位宽度。

   或者说 $O(\frac n W)$ ，此处 `n` 为 `b` 进制下数字的长度， `W` 为压位宽度。

### 三、模板示例

```c++
#include "IO/FastIO.h"
#include "MATH/BigInt.h"

int main() {
    using bint = OY::BigInt<>;
    // 无参构造为零
    bint zero;
    cout << "zero : " << zero << endl;
    // 可以从 int/long long 等构造
    bint one(1ll);
    cout << "one : " << one << endl;
    // 可以从 int128 构造
    bint a(__int128_t(123456789987654321));
    cout << "a : " << a << endl;
    // 可以从常量字符串或者 std::string 构造
    bint b("112233445566778899998877665544332211");
    cout << "b : " << b << endl;
    // 可以拷贝
    bint c(b);
    cout << "c : " << c << endl;

    // 生成 5 个位长为 7 的大数
    std::vector<bint> some(5);
    for (int i = 0; i < 5; i++) some[i] = bint::rand(7);
    for (int i = 0; i < 5; i++) cout << "some[" << i << "] = " << some[i] << endl;

    // 比较绝对值大小
    bint d(12345), e(-123456);
    auto comp_res = bint::absCompare(d, e);
    if (comp_res == 1)
        cout << "abs(" << d << ") > abs(" << e << ")" << endl;
    else if (comp_res == 0)
        cout << "abs(" << d << ") = abs(" << e << ")" << endl;
    else
        cout << "abs(" << d << ") < abs(" << e << ")" << endl;

    // 带余除法
    auto [q1, r1] = bint::div_mod<true>(a, d);
    cout << a << " / " << d << " = " << q1 << " , rem = " << r1 << endl;

    // 除数为 long long 的情况下
    long long f = 12345;
    auto [q2, r2] = bint::div_mod(a, f);
    cout << a << " / " << f << " = " << q2 << " , rem = " << r2 << endl;

    // 变为相反数
    cout << "d = " << d << endl;
    d.opposite();
    cout << "after opposite, d = " << d << endl;

    // 改变符号
    d.setSign(false);
    cout << "after setSign, d = " << d << endl;

    // 取位长
    auto len = a.length();
    cout << "length of " << a << " is " << len << endl;

    // 幂运算
    auto pow = a.pow(3);
    cout << a << "^3 = " << pow << endl;

    // 开根运算
    auto sqrt = pow.sqrt(6);
    cout << pow << "^(1/3) = " << sqrt << endl;

    // 强转为 bool
    if (zero)
        cout << zero << " is true\n";
    else
        cout << zero << " is false\n";
    if (one)
        cout << one << " is true\n";
    else
        cout << one << " is false\n";

    // 强转为 int
    int g(some[0]);
    cout << "g = " << g << endl;

    // 转换为 string
    std::string s(some[0]);
    cout << "s = " << s << endl;
}
```

```
#输出如下
zero : 0
one : 1
a : 123456789987654321
b : 112233445566778899998877665544332211
c : 112233445566778899998877665544332211
some[0] = 7211612
some[1] = 6346734
some[2] = 2404204
some[3] = 9919429
some[4] = 8962298
abs(12345) < abs(-123456)
123456789987654321 / 12345 = 10000550019251 , rem = 726
123456789987654321 / 12345 = 10000550019251 , rem = 726
d = 12345
after opposite, d = -12345
after setSign, d = 12345
length of 123456789987654321 is 18
123456789987654321^3 = 1881676416949388556641282847971835068037656108518161
1881676416949388556641282847971835068037656108518161^(1/3) = 351364184
0 is false
1 is true
g = 7211612
s = 7211612

```

