### 一、模板类别

​	数学：`Montgomery` 约减。

### 二、模板功能

#### 1.构造

1. 数据类型

   模板参数 `typename _ModType` ，可以为 `uint32_t` 或者 `uint64_t` ，表示模数的类型。

   构造参数 `_ModType __P` ，表示模数。

2. 时间复杂度

   $O(\log \log n)$ ，包含两次除法运算和 `8/10` 次乘法运算。

3. 备注

   本模板用于处理以某数为模数的连乘运算的加速。

   **注意：**本模板能够提高效率的情况为：模数在编译期未知，只有在运行期才知道对谁取余。如果编译期已知模数，那么本模板并不能提高效率。

   **注意：**本模板与巴雷特约减的区别是，巴雷特约减可用于加速除法、取余等各种运算，而蒙哥马利约减只能用于加速**连乘**运算。因为数字必须要调用 `init` 函数转换为待连乘状态，再调用 `reduce` 函数脱离连乘状态，恢复为普通数字，而这两个转换过程代价较大，所以只有在素性检验、分解质因数等连乘次数较多的时候，本模板才能体现出效率。

   **注意：**在 `64` 位版中，要求 `__P`  在 `(2, 2^63) ` 范围内，且为奇数。在 `32` 位版中，要求 `__P` 在 `(2, 2^31) ` 范围内，且为奇数。

#### 2.查询模数

1. 数据类型

2. 时间复杂度

   $O(1)$ 。

#### 3.快速求余

1. 数据类型

   输入参数 `uint64_t __a` ，表示要求余的数。要求传入非负数。

2. 时间复杂度

   $O(1)$ ，包含两次乘法运算，无除法运算。

3. 备注

   在底层运算中，除法运算耗时较大，而乘法运算耗时相对较小。
   
   本函数实际调用了巴雷特约减的相应函数。

#### 4.初始化为待连乘状态

1. 数据类型

   输入参数 `uint64_t __a` ，表示要进入连乘状态的数。

   返回类型 `_FastType` ，表示连乘状态表示。

2. 时间复杂度

   $O(1)$ ，包含若干次乘法运算，无除法运算。

#### 5.初始化为待连乘状态（无需取余版）

1. 数据类型

   输入参数 `uint64_t __a` ，表示要进入连乘状态的数。

   返回类型 `_FastType` ，表示连乘状态表示。

2. 时间复杂度

   $O(1)$ ，包含若干次乘法运算。

3. 备注

   本函数要求 `__a` 无需取余，也就是位于 `[0, mod())` 范围内。


#### 6.脱离连乘状态

1. 数据类型

   输入参数 `_FastType __a` ，表示要脱离连乘状态的数。

   返回类型 `_ModType` ，表示普通状态表示。

2. 时间复杂度

   $O(1)$ ，包含两次乘法运算，无除法运算。

#### 7.快速加法

1. 数据类型

   输入参数 `_FastType __a` ，表示第一个加数。

   输入参数 `_FastType __b` ，表示第二个加数。

2. 时间复杂度

   $O(1)$ ，无复杂运算。

3. 备注

   本函数返回和的模值。

   **注意：**本函数要求输入的两个加数都已取模。

#### 8.快速减法

1. 数据类型

   输入参数 `_FastType __a` ，表示被减数。

   输入参数 `_FastType __b` ，表示减数。

2. 时间复杂度

   $O(1)$ ，无复杂运算。

3. 备注

   本函数返回差的模值。

   **注意：**本函数要求输入的两个加数都已取模。

#### 9.快速乘法

1. 数据类型

   输入参数 `_FastType __a` ，表示第一个乘数。

   输入参数 `_FastType __b` ，表示第二个乘数。

   返回类型 `_FastType` ，表示乘积的连乘状态表示

2. 时间复杂度

   $O(1)$ ，包含三次乘法运算，无除法运算。

3. 备注

   在底层运算中，除法运算耗时较大，而乘法运算耗时相对较小。

   **注意：** 本函数要求输入的两个数都是已进入连乘状态的数。返回的数也在连乘状态内。

#### 10.快速幂

1. 数据类型

   输入参数 `_FastType __a` ，表示底数。

   输入参数 `uint64_t __n` ，表示指数。

   返回类型 `_FastType` ，表示幂结果的连乘状态表示

2. 时间复杂度

   $O(\log n)$ ，包含对数次乘法运算，无除法运算。

3. 备注

   在底层运算中，除法运算耗时较大，而乘法运算耗时相对较小。

   **注意：** 本函数要求输入的底数是已进入连乘状态的数，而指数是普通状态的数。返回的数也在连乘状态内。

#### 11.快速除法

1. 数据类型

   模板参数 `typename _Tp` ，表示被除数类型。

   输入参数 `_Tp __a` ，表示被除数。

2. 时间复杂度

   $O(1)$ ，包含两次乘法运算。

3. 备注

   本函数实际调用了巴雷特约减的相应函数。
   
#### 12.快速带余除法

1. 数据类型

   模板参数 `typename _Tp` ，表示被除数类型。

   输入参数 `_Tp __a` ，表示被除数。

   返回类型 `std::pair<_Tp, _Tp>` ，表示商和余数。

2. 时间复杂度

   $O(1)$ ，包含两次乘法运算。

3. 备注

   本函数实际调用了巴雷特约减的相应函数。

### 三、模板示例

```c++
#include "IO/FastIO.h"
#include "MATH/Montgomery.h"

int main() {
    //设置模数为 1000000007
    OY::Mongomery64 mg(1000000007);
    //其实蒙哥马利连乘结构体里，还包了一个巴雷特约减结构体
    OY::Barrett64&brt=mg.m_brt;

    cout << "mg's mod number:" << mg.mod() << endl;
    cout << "1596842379856 mod 1000000007 = " << mg.mod(1596842379856) << endl;
    cout << "12345678987654321 // 1000000007 = " << mg.divide(12345678987654321) << endl;
    auto [quo, rem] = mg.divmod(1596842379856);
    cout << "1596842379856 = " << quo << " * 1000000007 + " << rem << endl;

    //现在想计算一下 2 的 100 次方
    auto two=mg.init(2);
    cout << "pow(2,100) mod 1000000007 = " << mg.reduce(mg.pow(two,100)) << endl;

    //现在想计算一下两数乘积
    auto a=mg.init(59865278);
    auto b=mg.init(59846223);
    cout << "59865278 * 59846223 mod 1000000007 = " << mg.reduce(mg.multiply(a, b)) << endl;

    //如果想改变模数，可以重新声明一个变量，或者将原变量重新构造
    mg = OY::Mongomery64(233);
    cout << "mg's mod number:" << mg.mod() << endl;
}
```

```
#输出如下
mg's mod number:1000000007
1596842379856 mod 1000000007 = 842368684
12345678987654321 // 1000000007 = 12345678
1596842379856 = 1596 * 1000000007 + 842368684
pow(2,100) mod 1000000007 = 976371285
59865278 * 59846223 mod 1000000007 = 752066024
mg's mod number:233

```

