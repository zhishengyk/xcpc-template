### 一、模板类别

​	数学：斯特林数。

### 二、模板功能

#### 1.构造

1. 数据类型

   模板参数 `typename _Poly` ，表示多项式类。

   构造参数 `uint32_t __n` ，表示要计算的最大范围。

2. 时间复杂度

   $O(n\cdot\log\log n)$ 。

3. 备注

   由于在计算中大量用到乘法逆元，所以在构造函数中对乘法逆元进行打表。
   
   又由于在计算幂函数时需要用到质数筛优化，所以在构造函数中进行埃氏筛预处理。
   
   本模板提供第一类、第二类斯特林数完整打表和按行、按列打表的功能。
   
   模板参数 `_Poly` 不仅仅限制了多项式类，而且间接地通过多项式类限制了自取模数类，也就是限制了模数。


#### 2.完整打表第一类斯特林数

1. 数据类型

   输入参数 `uint32_t __n` ，表示打表范围。

   返回类型 `std::vector<_Poly>` ，表示打表结果。

2. 时间复杂度

   $O(n^2)$ 。
   
3. 备注

   本方法返回长度为 `__n+1` 的二维数组，表示从 `0` 到 `__n` 行的第一类斯特林数，其中 `i` 行的长度是 `i+1` 。

#### 3.完整打表第二类斯特林数

1. 数据类型

   输入参数 `uint32_t __n` ，表示打表范围。

   返回类型 `std::vector<_Poly>` ，表示打表结果。

2. 时间复杂度

   $O(n^2)$ 。

3. 备注

   本方法返回长度为 `__n+1` 的二维数组，表示从 `0` 到 `__n` 行的第二类斯特林数，其中 `i` 行的长度是 `i+1` 。

#### 4.按行打表第一类斯特林数

1. 数据类型

   输入参数 `uint32_t __row` ，表示打表行号。

   返回类型 `_Poly` ，表示查询当行的第一类斯特林数。

2. 时间复杂度

   $O(n\cdot\log n)$ 。
   
3. 备注

   本方法返回一行第一类斯特林数，长度为 $\_\_row+1$ 。
   
4. 生成函数

   待补。

#### 5.按行打表第二类斯特林数

1. 数据类型

   输入参数 `uint32_t __row` ，表示打表行号。

   返回类型 `_Poly` ，表示查询当行的第二类斯特林数。

2. 时间复杂度

   $O(n\cdot\log n)$ 。

3. 备注

   本方法返回一行第二类斯特林数，长度为 `__row+1` 。
   
4. 生成函数

   待补。

#### 6.按列打表第一类斯特林数

1. 数据类型

   输入参数 `uint32_t __col` ，表示打表列号。

   输入参数 `uint32_t __maxRow` ，表示打表最大行号。

   返回类型 `_Poly` ，表示查询当列的第一类斯特林数。

2. 时间复杂度

   $O(n\cdot\log n)$ 。
   
3. 备注

   由于第一类斯特林数在矩阵中处于左下三角位置，所以在第 `__col` 列中，行号小于 `__col` 的值均为零。所以本模板需要额外的参数指定最大行号，且仅当最大行号达到 `__col` 的大小时，才有非零值返回。本方法的返回长度为 `__maxRow+1` 。
   
4. 生成函数

   待补。

#### 7.按列打表第二类斯特林数

1. 数据类型

   输入参数 `uint32_t __col` ，表示打表列号。

   输入参数 `uint32_t __maxRow` ，表示打表最大行号。

   返回类型 `_Poly` ，表示查询当列的第二类斯特林数。

2. 时间复杂度

   $O(n\cdot\log n)$ 。

3. 备注

   由于第二类斯特林数在矩阵中处于左下三角位置，所以在第 `__col` 列中，行号小于 `__col` 的值均为零。所以本模板需要额外的参数指定最大行号，且仅当最大行号达到 `__col` 的大小时，才有非零值返回。本方法的返回长度为 `__maxRow+1` 。
   
4. 生成函数

   待补。

### 三、模板示例

```c++
#include "IO/FastIO.h"
#include "MATH/StirlingNumber.h"

using mint = OY::StaticModInt32<998244353, true>;
using poly = OY::NTTPolynomial<mint, 1 << 18>;
int main() {
    // 只要用到 ntt 记得设置原根
    poly::s_primitiveRoot = 3;

    OY::StirlingNumber<poly> sn(100);

    // 第一类斯特林数完整打表
    auto sn1 = sn.getFirstStirlingTable(6);
    for (int i = 0; i <= 6; i++)
        cout << sn1[i] << endl;

    // 第一类斯特林数打出第 4 行
    auto sn1_row = sn.getFirstStirlingRow(4);
    cout << sn1_row << endl;

    // 第一类斯特林数打出第 4 列，最大行数指定为 6
    auto sn1_col = sn.getFirstStirlingCol(4, 6);
    cout << sn1_col << endl;

    // 第二类斯特林数完整打表
    auto sn2 = sn.getSecondStirlingTable(6);
    for (int i = 0; i <= 6; i++)
        cout << sn2[i] << endl;

    // 第二类斯特林数打出第 4 行
    auto sn2_row = sn.getSecondStirlingRow(4);
    cout << sn2_row << endl;

    // 第二类斯特林数打出第 4 列，最大行数指定为 6
    auto sn2_col = sn.getSecondStirlingCol(4, 6);
    cout << sn2_col << endl;
}
```

```
#输出如下
1 
0 1 
0 1 1 
0 2 3 1 
0 6 11 6 1 
0 24 50 35 10 1 
0 120 274 225 85 15 1 
0 6 11 6 1 
0 0 0 0 1 10 85 
1 
0 1 
0 1 1 
0 1 3 1 
0 1 7 6 1 
0 1 15 25 10 1 
0 1 31 90 65 15 1 
0 1 7 6 1 
0 0 0 0 1 10 65 

```

