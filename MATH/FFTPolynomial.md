### 一、模板类别

​	数学：基于快速傅里叶变换的多项式。

### 二、模板功能

#### 1.构造

1. 数据类型

   模板参数 `typename _Tp` ，表示多项式的系数元素类型。默认为 `uint32_t` 。

   模板参数 `uint32_t _MAXN` ，表示多项式的最大项数。一般要设为 `2` 的整数次幂，默认为 `1<<22` 。

   模板参数 `typename _Fp` ，表示进行快速傅里叶变换时，复数的浮点数类型。默认为 `double` 。

2. 时间复杂度

   取决于构造函数。

3. 备注

   本模板基于快速傅里叶变换，在 $O(n\cdot \log n)$ 的时间内实现多项式乘法。

   下文以 `poly` 代指本模板类。

   `poly` 继承了 `std::vector<_Tp>` ，数组中的每个元素都是一个系数，对应的次数是这个元素的下标。

   模板参数 `_Tp` 仅推荐使用 `uint32_t` 或者更小的数据类型，且不能使用自取模数类。理论上也可以使用 `uint64_t` ，但是系数绝对值越大，在乘法运算时精度误差出现的风险越大。

   模板参数 `_MAXN` 需达到使用过程中出现的多项式最多项数。如果需要处理两个项数为`16` 的多项式的乘法，乘积项数会达到 `31` ，那么 `_MAXN`  须设为 `32` 。

   模板参数 `_Fp` 可以为 `float` ，`double` ，或者 `long double` 。`float` 由于精度过低，不推荐使用；一般使用 `double` 可以满足精度要求。在系数值域较大的情况下可以使用 `long double` 。经测试， `float` 仅当乘积多项式的系数在 `1e6` 范围内时安全；`double`·当乘积多项式的系数在 `1e15`  范围内时安全；`long double` 当乘积多项式的系数在 `1e18`  范围内时安全。
   
   以下划线开始的成员方法，在文档中不做介绍。

#### 2.预备

1. 数据类型

   输入参数 `uint32_t __length` ，表示要进行快速傅里叶变换的长度。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   本方法一般无须手动调用，而是在进行快速傅里叶变换前夕自动调用。

#### 3.快速傅里叶变换

1. 数据类型

   输入参数 `_Iterator __iter` ，表示要进行快速傅里叶变换的区间首位置的迭代器。

   输入参数 `uint32_t __length` ，表示要进行快速傅里叶变换的区间长度。

   返回类型 `_Iterator` ，返回区间首位置的迭代器，便于链式调用。

2. 时间复杂度

   $O(n\cdot \log n )$ 。

3. 备注

   迭代器 `__iter` 的值类型须为 `complex` ，即复数类型。

#### 4.快速傅里叶变换

1. 数据类型

   输入参数 `_Iterator __iter` ，表示要进行快速傅里叶变换的区间首位置的迭代器。

   输入参数 `uint32_t __dfsLength` ，表示要进行快速傅里叶变换的区间长度。

   输入参数 `_Iterator2 __source` ，表示数据源。

   输入参数 `uint32_t __sourceLength` ，表示从数据源截取的数据长度。

   返回类型 `_Iterator` ，返回区间首位置的迭代器，便于链式调用。

2. 时间复杂度

   $O(n\cdot \log n )$ 。

3. 备注

   迭代器 `__iter` 的值类型须为 `complex` ，即复数类型。

   迭代器 `__source` 的值类型为 `_Tp` ，从 `__source` 截取数据送到 `__iter` ，再对 `__iter` 进行快速傅里叶变换。

#### 5.快速傅里叶逆变换

1. 数据类型

   输入参数 `_Iterator __iter` ，表示要进行快速傅里叶逆变换的区间首位置的迭代器。

   输入参数 `uint32_t __length` ，表示要进行快速傅里叶逆变换的区间长度。

   返回类型 `_Iterator` ，返回区间首位置的迭代器，便于链式调用。

2. 时间复杂度

   $O(n\cdot \log n )$ 。

3. 备注

   迭代器 `__iter` 的值类型须为 `complex` ，即复数类型。

   显然，快速傅里叶逆变换为快速傅里叶变换的逆运算。

#### 6.获取两个 poly 的循环乘积

1. 数据类型

   输入参数 `const poly&__a` ，表示第一个 `poly` 。

   输入参数 `const poly&__b` ，表示第二个 `poly` 。

   输入参数 `uint32_t __length` ，表示指定快速傅里叶变换的长度。

   返回类型 `poly` ，表示循环卷积结果。

2. 时间复杂度

   $O(n\cdot \log n)$ 。

3. 备注

   显然，`__a` 和 `__b` 超过 `__length` 长度外的项不会参与运算。

   注意到即使 `__a` 和 `__b` 参与运算的项数少于 `__length` ，乘积项数有可能超过 `__length` ，所以本方法的运算结果并不是乘积，而是循环卷积。可以参考示例代码。

#### 7.收缩

1. 数据类型

   返回类型 `poly&` ，表示返回对自身的引用，便于链式调用。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   将多项式的最高次零消除掉。


#### 8.反转

1. 数据类型

   返回类型 `poly&` ，表示返回对自身的引用，便于链式调用。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   将多项式的所有项按次数高低反转。

#### 9.改变大小

1. 数据类型

   输入参数 `uint32_t __size` ，表示要改变为的项数。

   返回类型 `poly&` ，表示返回对自身的引用，便于链式调用。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   如果 `__size` 大于当前项数，则填充零；如果 `__size` 小于当前项数，则直接截取。

#### 10.获取某次项的系数

1. 数据类型

   输入参数 `uint32_t __i` ，表示次数。

2. 时间复杂度

   $O(1)$ ，无复杂运算。

3. 备注

   如果 `__i` 在项数范围内，返回相应系数；否则直接返回零。

#### 11.各种运算符

1. 数据类型

2. 时间复杂度

   对于`+` (正号) ， `-` (负号) ，  `+` ， `-` ， `+=` ， `-=` ，以及与一个 `_Tp` 类型进行 `*` ， `/` ， `*=` ， `/=` 运算符，时间复杂度为 $O(n)$ 。

   对于 `poly` 与 `poly` 之间进行 `*` ， `*=` 运算符，时间复杂度为 $O(n\cdot \log n)$ 。


#### 12.单点求值

1. 数据类型

   输入参数 `_Tp __x` ，表示自变量的值。

   返回类型 `_Tp` ，表示带入自变量后多项式的求值结果。

2. 时间复杂度

   $O(n)$ 。


### 三、模板示例

```c++
#include "IO/FastIO.h"
#include "MATH/FFTPolynomial.h"
#include <random>

using poly = OY::FFTPolynomial<uint32_t, 1 << 10, double>;
int main() {
    // 一个项数为 4 的多项式
    poly A(4);
    // 填充随机数
    std::mt19937 rand(1);
    for (auto &a : A) a = rand() % 10;
    // 输出 A ，A = 5 + 9 x + 4 x^2 + 8 x^3
    cout << "A : " << A << endl;

    // 再来一个多项式
    poly B(3, 2);
    // 输出 B，B = 2 + 2 x + 2 x^2
    cout << "B : " << B << endl;

    // 输出四则运算结果
    cout << "A + B = " << A + B << endl;
    cout << "A - B = " << A - B << endl;
    cout << "A * B = " << A * B << endl;
    cout << "A * 8 = " << A * 8 << endl;
    cout << "B / 2 = " << B / 2 << endl;

    // 将 A 高低位反转
    A.reverse();
    // 输出 A ，A = 8 + 4 x + 9 x^2 + 5 x^3
    cout << "A : " << A << endl;

    // 将 B 重置大小
    B.sizeTo(4);
    // 输出 B，B = 2 + 2 x + 2 x^2 + 0 x^3
    cout << "B : " << B << endl;

    // ******************************************************************
    // 如果要搞清楚乘法运算的计算流程，可以往下看
    using complex = poly::complex;
    // 预备。当然，即使不手动预备，一会也会自动预备
    poly::prepareDFT(8);
    // 准备两块 复数 buffer
    complex buffer_A[8], buffer_B[8];
    // 把 A 的数据送过去，转化成复数
    std::copy_n(A.begin(), A.size(), buffer_A);
    std::fill(buffer_A + A.size(), buffer_A + 8, 0);
    // 对复数进行快速傅里叶变换
    poly::dft(buffer_A, 8);
    // 上述流程可以简化成一句代码
    poly::dft(buffer_B, 8, B.begin(), B.size());
    // 令两块复数数组，对应相乘
    for (int i = 0; i < 8; i++) buffer_A[i] *= buffer_B[i];
    // 进行快速傅里叶逆变换
    poly::idft(buffer_A, 8);
    // 现在可以得到乘积多项式了
    poly product(buffer_A, buffer_A + 8);
    cout << product << endl;
    // 用 shrink 消掉高项零
    product.shrink();
    cout << product << endl;

    // ******************************************************************
    // 你也许会问，为啥快速傅里叶变换区间长度设为了 8，设成 4 会怎么样
    // 我们直接看一下以 4 为长度进行循环卷积的结果
    auto res = poly::product(A, B, 4);
    // 经观察，结果里的第 5 项加到了第 1 项上，第 6 项加到了第 2 项上，这个就是循环卷积的意思
    cout << "poly::product(A,B,4) = " << res << endl;
}
```

```
#输出如下
A : 5 9 4 8 
B : 2 2 2 
A + B = 7 11 6 8 
A - B = 3 7 2 8 
A * B = 10 28 36 42 24 16 
A * 8 = 40 72 32 64 
B / 2 = 1 1 1 
A : 8 4 9 5 
B : 2 2 2 0 
16 24 42 36 28 10 0 0 
16 24 42 36 28 10 
poly::product(A,B,4) = 44 34 42 36 

```

