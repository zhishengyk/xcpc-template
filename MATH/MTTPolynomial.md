### 一、模板类别

​	数学：基于拆系数快速傅里叶变换的多项式。

### 二、模板功能

#### 1.构造

1. 数据类型

   模板参数 `typename _Tp` ，表示多项式的系数元素类型，可以为任意一种自取模数类。

   模板参数 `uint32_t _MAXN` ，表示多项式的最大项数。要设为 `2` 的整数次幂，默认为 `1 << 22` 。

   模板参数 `typename _Fp` ，表示进行快速傅里叶变换时，复数的浮点数类型。默认为 `double` 。

   模板参数 `uint32_t _Split = 1 << 15` ，表示拆系数的分界点。

2. 时间复杂度

   取决于构造函数。

3. 备注

   本模板基于快速傅里叶变换，在 $O(n\cdot \log n)$ 的时间内实现多项式乘法。

   本模板 `MTTPolynomial` 和 `NTTPolynomial` 的区别是，本模板的模数可以取任何质数。

   本模板 `MTTPolynomial` 和 `NTTPolynomial_ex` 的区别是，本模板使用的是快速傅里叶变换。然而，常用的浮点数即使是 `long double`  在数字接近 `long long` 上限时就会产生肉眼可见的精度误差。不妨假设多项式项数为 `1e5` ，系数值域 `1e9` ，那么两个多项式的乘积的系数就可以达到 `1e23` 的数量级，超出 `long double` 的精度范围。所以这里采用了把系数值域拆分的方法进行处理。

   下文以 `poly` 代指本模板类。

   `poly` 继承了 `std::vector<_Tp>` ，数组中的每个元素都是一个系数，对应的次数是这个元素的下标。

   模板参数 `_Tp` 须填写自取模数类。

   模板参数 `_MAXN` 需达到使用过程中出现的多项式最多项数。如果需要处理两个项数为`16` 的多项式的乘法，乘积项数会达到 `31` ，那么 `_MAXN`  须设为 `32` 。

   `_Tp` 须满足： 设 `P = _Tp::mod()` 为自取模数类的模数，那么`P` 必须是质数。

   以下划线开始的成员方法，在文档中不做介绍。
   
   **注意：**快速插值和多点求值部分的代码，占用 $O(n\log n)$ 的空间。如果空间限制吃紧，可以把这部分删掉，这部分代码集中在模板最下端。

#### 2.预备

1. 数据类型

   输入参数 `uint32_t __length` ，表示要进行快速傅里叶变换的长度。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   本方法一般无须手动调用，而是在进行快速傅里叶变换前夕自动调用。

#### 3.快速傅里叶变换

1. 数据类型

   输入参数 `_Iterator __iter` ，表示要进行快速傅里叶变换的区间首位置的迭代器。

   输入参数 `uint32_t __length` ，表示要进行快速傅里叶变换的区间长度。

   返回类型 `_Iterator` ，返回区间首位置的迭代器，便于链式调用。

2. 时间复杂度

   $O(n\cdot \log n )$ 。

3. 备注

   迭代器 `__iter` 的值类型须为 `triple` 。

#### 4.快速傅里叶变换

1. 数据类型

   输入参数 `_Iterator __iter` ，表示要进行快速傅里叶变换的区间首位置的迭代器。

   输入参数 `uint32_t __dfsLength` ，表示要进行快速傅里叶变换的区间长度。

   输入参数 `_Iterator2 __source` ，表示数据源。

   输入参数 `uint32_t __sourceLength` ，表示从数据源截取的数据长度。

   返回类型 `_Iterator` ，返回区间首位置的迭代器，便于链式调用。

2. 时间复杂度

   $O(n\cdot \log n )$ 。

3. 备注

   迭代器 `__iter` 的值类型须为 `triple` 。

   迭代器 `__source` 的值类型为 `_Tp` ，从 `__source` 截取数据送到 `__iter` ，再对 `__iter` 进行快速傅里叶变换。

#### 5.快速傅里叶逆变换

1. 数据类型

   输入参数 `_Iterator __iter` ，表示要进行快速傅里叶逆变换的区间首位置的迭代器。

   输入参数 `uint32_t __length` ，表示要进行快速傅里叶逆变换的区间长度。

   返回类型 `_Iterator` ，返回区间首位置的迭代器，便于链式调用。

2. 时间复杂度

   $O(n\cdot \log n )$ 。

3. 备注

   迭代器 `__iter` 的值类型须为 `triple_pair` 。

   显然，快速傅里叶逆变换为快速傅里叶变换的逆运算。

#### 6.预备逆元

1. 数据类型

   输入参数 `uint32_t __length` ，表示要预备逆元的值域范围。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   在积分、对数、指数计算过程中，需要用到逆元；使用时无需手动调用，而是自动调用。

#### 7.对区间求导

1. 数据类型

   输入参数 `_Iterator __iter` ，表示要进行求导的区间首位置的迭代器。

   输入参数 `uint32_t __length` ，表示要进行求导的区间长度。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   本方法会将传入区间的每个元素，依次视为一个多项式的零次项、一次项……以此类推。

   对非空多项式，求导后，项数会减少一，本方法会将最高次项的位置置为零。

#### 8.对区间积分

1. 数据类型

   输入参数 `_Iterator __iter` ，表示要进行积分的区间首位置的迭代器。

   输入参数 `uint32_t __length` ，表示要进行积分的区间长度。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   本方法会将传入区间的每个元素，依次视为一个多项式的零次项、一次项……以此类推。

   **注意：**对非空多项式，积分后，项数会增加一，所以在使用时需保证预留 `__length+1` 长度的位置。

#### 9.获取两个 poly 的循环乘积

1. 数据类型

   输入参数 `const poly&__a` ，表示第一个 `poly` 。

   输入参数 `const poly&__b` ，表示第二个 `poly` 。

   输入参数 `uint32_t __length` ，表示指定快速傅里叶变换的长度。

   返回类型 `poly` ，表示循环卷积结果。

2. 时间复杂度

   $O(n\cdot \log n)$ 。

3. 备注

   显然，`__a` 和 `__b` 超过 `__length` 长度外的项不会参与运算。

   注意到即使 `__a` 和 `__b` 参与运算的项数少于 `__length` ，乘积项数有可能超过 `__length` ，所以本方法的运算结果并不是乘积，而是循环卷积。可以参考示例代码。

#### 10.收缩

1. 数据类型

   返回类型 `poly&` ，表示返回对自身的引用，便于链式调用。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   将多项式的最高次零消除掉。


#### 11.反转

1. 数据类型

   返回类型 `poly&` ，表示返回对自身的引用，便于链式调用。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   将多项式的所有项按次数高低反转。

#### 12.改变大小

1. 数据类型

   输入参数 `uint32_t __size` ，表示要改变为的项数。

   返回类型 `poly&` ，表示返回对自身的引用，便于链式调用。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   如果 `__size` 大于当前项数，则填充零；如果 `__size` 小于当前项数，则直接截取。

#### 13.求导

1. 数据类型

   返回类型 `poly&` ，表示返回对自身的引用，便于链式调用。

2. 时间复杂度

   $O(n)$ 。

3. 备注

   对非空多项式，求导后，项数会减少一。

#### 14.积分

1. 数据类型

   返回类型 `poly&` ，表示返回对自身的引用，便于链式调用。

2. 时间复杂度

    $O(n)$ 。

3. 备注

   对非空多项式，积分后，项数会增加一，所以在使用时需保证预留 `__length+1` 长度的位置。

#### 15.获取某次项的系数

1. 数据类型

   输入参数 `uint32_t __i` ，表示次数。

2. 时间复杂度

   $O(1)$ ，无复杂运算。

3. 备注

   如果 `__i` 在项数范围内，返回相应系数；否则直接返回零。

#### 16.各种运算符

1. 数据类型

2. 时间复杂度

   对于`+` (正号) ， `-` (负号) ，  `+` ， `-` ， `+=` ， `-=` ，以及与一个 `_Tp` 类型进行 `*` ， `/` ， `*=` ， `/=` 运算符，时间复杂度为 $O(n)$ 。

   对于 `poly` 与 `poly` 之间进行 `*` ， `*=` 运算符，时间复杂度为 $O(n\cdot \log n)$ 。


#### 17.单点求值

1. 数据类型

   输入参数 `_Tp __x` ，表示自变量的值。

   返回类型 `_Tp` ，表示带入自变量后多项式的求值结果。

2. 时间复杂度

   $O(n)$ 。

#### 18.对等比数列求值

1. 数据类型

   输入参数 `_Tp __x` ，表示自变量的底数。

   输入参数 `uint32_t __n` ，表示自变量的指数的范围。

   返回类型 `poly` ，表示带入自变量后多项式的求值结果。

2. 时间复杂度

   $O(n\cdot\log n)$ 。

3. 备注

   本算法称为 `Chirp Z` 变换，或者 `Bluestein` 算法。

   本方法返回在 `1` ，`__x` ，`__x^2` ，……， `__x^(__n-1)` 等点处的多项式值。
   
   返回的多项式恰有 `__n` 项，对应 `__n` 个点处的值。

#### 19.求逆

1. 数据类型

   返回类型 `poly` ，表示多项式的逆。

2. 时间复杂度

   $O(n\cdot\log n)$ 。

3. 备注

   设原多项式 `f` 的项数为 `__n` ，`g` 为 `f` 的逆。则 `f * g` 在去掉次数大于等于 `__n` 的项之后，只剩常数项，且常数值为 `1` 。

   逆的项数一定小于等于原多项式的项数，但是本方法返回固定 `__n` 项数的逆，未去掉高位零。

   **注意：**
   
   1. 本方法默认原多项式不含高位零。
   2. 当原多项式的常数项为零的时候，逆无意义。

#### 20.平方根

1. 数据类型

   输入参数 `_Tp __a0` ，表示原多项式常数项的平方根。默认值为 `1` 。

   返回类型 `poly` ，表示多项式的逆。

2. 时间复杂度

   $O(n\cdot\log n)$ 。

3. 备注

   设原多项式 `f` 的项数为 `__n` ，`g` 为 `f` 的平方根。则 `g * g` 在去掉次数大于等于 `__n` 的项之后，恰好等于 `f` 。

   平方根的项数一定小于等于原多项式的项数，但是本方法返回固定 `__n` 项数的平方根，未去掉高位零。

   之所以 `__a0` 需要保留一个接口，是因为在模意义下计算平方根本身就是一件难事，需要借助二次剩余模板，如 `Cipolla` 模板。在一般题目中，原多项式的常数项值为 `1` ，所以可以使用默认的 `__a0 = 1` 。当然，即使是常数项为 `1` ，平方根也并非必须为 `1` ，模意义下的 `-1` 显然也是可以的。
   
   **注意：** 本方法默认原多项式不含高位零。

#### 21.带余除法

1. 数据类型

   输入参数 `const poly&__other` ，表示作为除数的多项式。

   返回类型 `std::pair<poly, poly>` ，表示商和余数。

2. 时间复杂度

   $O(n\cdot\log n)$ 。

3. 备注

   原多项式作为被除数存在。

   设原多项式 `f` 的项数为 `n` ，除数`g` 的项数为 `m` 。计算得商 `q` ，余数 `r` 。则 `f = g * q + r` 。商 `q` 的项数不超过 `n - m + 1` ，余数 `r` 的项数不超过 `m - 1` 。

   当 `n < m` 时，本方法直接返回 `{poly(), *this}` 。

   当 `n >= m` 时，本方法返回的 `q` 固定项数为 `n - m + 1` ，未去掉高位零。`r`的项数则不固定。

   **注意：** 
   
   1. 本方法默认原多项式和除数多项式不含高位零。
   2. 当除数多项式为空的时候，本方法无意义。

#### 22.多项式除法

1. 数据类型

   输入参数 `const poly&__other` ，表示作为除数的多项式。

   输入参数 `uint32_t __length` ，表示商的“精度”。默认为 `-1` 。

   返回类型 `poly` ，表示商。

2. 时间复杂度

   $O(n\cdot\log n)$ 。

3. 备注

   原多项式作为被除数存在。

   设原多项式 `f` 的项数为 `n` ，除数`g` 的项数为 `m` ，商的精度设为 `l` 。计算得商 `q` 。则 `q` 固定项数为 `l` 。设 `f' = g * q` ，则 `f'` 的项数为 `l + m - 1`，且 `f'`  的最高 `l` 位和 `f` 的最高 `l` 位保持相等。

   **注意：** 

   1. 本方法默认原多项式和除数多项式不含高位零。
2. 当除数多项式为空的时候，本方法无意义。

#### 23.多项式取余

1. 数据类型

   输入参数 `const poly&__other` ，表示作为除数的多项式。

   返回类型 `poly` ，表示余数。

2. 时间复杂度

   $O(n\cdot\log n)$ 。

3. 备注

   原多项式作为被除数存在。

   本方法返回带余除法中的商多项式。

   **注意：** 

   1. 本方法默认原多项式和除数多项式不含高位零。
   2. 当除数多项式为空的时候，本方法无意义。

#### 24.多项式对数

1. 数据类型

   返回类型 `poly` ，表示多项式的对数。

2. 时间复杂度

   $O(n\cdot\log n)$ 。

3. 备注

   **注意：** 

   1. 本方法默认原多项式不含高位零。
   2. 当原多项式的常数项不为一的时候，本方法无意义。所以必须保证原多项式常数项为 `1` 。

#### 25.多项式指数

1. 数据类型

   返回类型 `poly` ，表示多项式的指数。

2. 时间复杂度

   $O(n\cdot\log n)$ 。

3. 备注

   **注意：** 

   1. 本方法默认原多项式不含高位零。
   2. 当原多项式的常数项不为零的时候，本方法无意义。所以必须保证原多项式常数项为 `0` 。

#### 26.多项式快速幂

1. 数据类型

   输入参数 `_Tp __n1` ，表示指数大小。

   输入参数 `_Tp2 __n2` ，表示指数大小。

   输入参数 `uint64_t __nAbs` ，表示指数绝对值大小，默认为 `UINT64_MAX` 。

   返回类型 `poly` ，表示多项式的幂。

2. 时间复杂度

   $O(n\cdot\log n)$ 。

3. 备注

   原多项式作为底数存在。

   本方法返回多项式快速幂的结果，幂的项数一般大于原多项式的项数，也有可能小于原多项式的项数（比如指数为 `0` ）。但是本方法返回固定 `__n` 项数的快速幂，未去掉高位零。

   **注意：**  本方法的三个参数，从三个角度对指数进行了传递。

   1. 第一个参数 `_Tp __n1` ，是指数在 `_Tp` 模数下的值。所以这个值的类型和多项式元素类型相同。
   2. 第二个参数 `_Tp2 __n1` ，是指数在 `_Tp` 模数的欧拉函数作为模数的情况下的取值。由于 `_Tp` 被限定为质数，所以 `_Tp2` 是以 `_Tp::mod()-1` 作为模数的自取模数类。
   3. 第三个参数，是指数的绝对值大小。这个绝对值是用来指示前导零数量的；所以当指数大于一定程度时，可以统统传递默认值。只有指数较小的时候，才有必要传递精确的指数绝对值。

#### 27.多项式快速插值

1. 数据类型

   输入参数 `const poly& __xs` ，表示自变量们。

   输入参数 `const poly& __ys` ，表示自变量对应的因变量们。

   返回类型 `poly` ，表示插值得到的多项式。

2. 时间复杂度

   $O(n\cdot\log^2 n)$ 。

3. 备注

   本方法通过一些点值，反推多项式每项的系数。

   当输入 `n` 组变量的情况下，得到的插值多项式最多可以有 `n` 项。实际返回固定项数 `n` 的结果，未去掉高位零。

   **注意：** 本方法须保证输入的数据合法，即不存在一个自变量对应多个因变量的情况。

#### 28.多项式多点求值

1. 数据类型

   输入参数 `const poly& __xs` ，表示自变量们。

   返回类型 `poly` ，表示带入自变量后多项式的求值结果。

2. 时间复杂度

   $O(n\cdot\log^2 n)$ 。
   
3. 备注

   本方法在已知原多项式系数的情况下，输入一些自变量，求出它们对应的因变量。


### 三、模板示例

```c++
#include "IO/FastIO.h"
#include "MATH/MTTPolynomial.h"
#include "MATH/StaticModInt32.h"
#include <random>

// 常用的模数 1000000007
using mint = OY::StaticModInt32<1000000007, true>;
using poly = OY::MTTPolynomial<mint, 1 << 12>;
int main() {
    // 和 NTTPolynomial_ex 功能可以说一模一样，这里不再演示
    // 一个项数为 4 的多项式
    poly A(4);
    // 填充随机数
    std::mt19937 rand(1);
    for (auto &a : A) a = rand() % 10;
    // 输出 A ，A = 5 + 9 x + 4 x^2 + 8 x^3
    cout << "A : " << A << endl;

    // 再来一个多项式
    poly B(3, 2);
    // 输出 B，B = 2 + 2 x + 2 x^2
    cout << "B : " << B << endl;

    // ******************************************************************
    // 如果要搞清楚 MTT 乘法运算的计算流程，可以往下看
    using complex = poly::complex;
    using complex_pair = poly::complex_pair;
    // 预备。当然，即使不手动预备，一会也会自动预备
    poly::prepareDFT(8);
    // 准备两块 complex buffer
    complex buffer_A[8], buffer_B[8];
    // 准备一块 complex_pair buffer
    complex_pair buffer[8];
    // 把 A 的数据送过去，转化成复数
    std::copy_n(A.begin(), A.size(), buffer_A);
    std::fill(buffer_A + A.size(), buffer_A + 8, 0);
    // 对复数进行快速傅里叶变换
    poly::dft(buffer_A, 8);
    // 上述流程可以简化成一句代码
    poly::dft(buffer_B, 8, B.begin(), B.size());
    // 令两块 complex 数组在 complex_pair 数组上进行变换
    poly::_transform(buffer, buffer_A, buffer_B, 8);
    // 进行快速傅里叶逆变换
    poly::idft(buffer, 8);
    // 现在可以得到乘积多项式了
    poly product(buffer, buffer + 8);
    cout << product << endl;
    // 用 shrink 消掉高项零
    product.shrink();
    cout << product << endl;
}
```

```
#输出如下
A : 5 9 4 8 
B : 2 2 2 
10 28 36 42 24 16 0 0 
10 28 36 42 24 16 

```

